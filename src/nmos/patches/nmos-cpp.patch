diff --git a/Development/cmake/NmosCppNode.cmake b/Development/cmake/NmosCppNode.cmake
index df1ab1c..ab18c67 100644
--- a/Development/cmake/NmosCppNode.cmake
+++ b/Development/cmake/NmosCppNode.cmake
@@ -1,19 +1,31 @@
 # nmos-cpp-node executable
-
 set(NMOS_CPP_NODE_SOURCES
     nmos-cpp-node/main.cpp
     nmos-cpp-node/node_implementation.cpp
+    nmos-cpp-node/intel_config_parser.cpp
     )
 set(NMOS_CPP_NODE_HEADERS
     nmos-cpp-node/node_implementation.h
+    nmos-cpp-node/intel_config_parser.h
     )
+# Find gRPC installation
+# Looks for gRPCConfig.cmake file installed by gRPC's cmake installation.
+set(protobuf_MODULE_COMPATIBLE TRUE)
+find_package(Protobuf CONFIG REQUIRED)
+message(STATUS "Using protobuf ${Protobuf_VERSION}")
+set(_PROTOBUF_LIBPROTOBUF protobuf::libprotobuf)
+set(_REFLECTION gRPC::grpc++_reflection)
+find_package(gRPC CONFIG REQUIRED)
+message(STATUS "Using gRPC ${gRPC_VERSION}")
 
 add_executable(
     nmos-cpp-node
     ${NMOS_CPP_NODE_SOURCES}
     ${NMOS_CPP_NODE_HEADERS}
     nmos-cpp-node/config.json
-    )
+    nmos-cpp-node/config_params.hpp
+    nmos-cpp-node/FFmpeg_wrapper_client.h
+)
 
 source_group("Source Files" FILES ${NMOS_CPP_NODE_SOURCES})
 source_group("Header Files" FILES ${NMOS_CPP_NODE_HEADERS})
@@ -22,6 +34,10 @@ target_link_libraries(
     nmos-cpp-node
     nmos-cpp::compile-settings
     nmos-cpp::nmos-cpp
+    FFmpeg_wrapper_client
+    protobuf::libprotobuf
+    hw_grpc_proto
+    gRPC::grpc++
     )
 # root directory to find e.g. nmos-cpp-node/node_implementation.h
 target_include_directories(nmos-cpp-node PRIVATE
diff --git a/Development/conanfile.txt b/Development/conanfile.txt
index aa55298..fdc9ace 100644
--- a/Development/conanfile.txt
+++ b/Development/conanfile.txt
@@ -15,6 +15,7 @@ lib, *.dylib* -> ./lib
 
 [options]
 boost/*:shared=False
+openssl/*:shared=True
 
 [generators]
 CMakeDeps
diff --git a/Development/nmos-cpp-node/intel-node-rx.json b/Development/nmos-cpp-node/intel-node-rx.json
new file mode 100644
index 0000000..806b649
--- /dev/null
+++ b/Development/nmos-cpp-node/intel-node-rx.json
@@ -0,0 +1,67 @@
+{
+  "logging_level": 0,
+  "http_port": 95,
+  "label": "intel-broadcast-suite",
+  "activate_senders": false,
+  "senders": ["v"],
+  "senders_count": [0],
+  "receivers": ["v"],
+  "receivers_count": [1],
+  "device_tags": {
+    "pipeline": ["rx"]
+  },
+  "function": "rx",
+  "gpu_hw_acceleration": "none",
+  "color_sampling": "YCbCr-4:2:2",
+  "domain": "local",
+  "ffmpeg_grpc_server_address": "localhost",
+  "ffmpeg_grpc_server_port": "50052",
+  "receiver_payload_type":112,
+  "frame_rate": { "numerator": 60000, "denominator": 1001 },
+  "sender": [{
+    "stream_payload": {
+      "video": {
+        "frame_width": 1920,
+        "frame_height": 1080,
+        "frame_rate": { "numerator": 60, "denominator": 1 },
+        "pixel_format": "yuv422p10le",
+        "video_type": "rawvideo"
+      },
+      "audio": {
+        "channels": 2,
+        "sampleRate": 48000,
+        "format": "pcm_s24be",
+        "packetTime": "1ms"
+      }
+    },
+    "stream_type": {
+      "file": {
+        "path": "/root/recv",
+        "filename": "1920x1080p10le_2.yuv"
+      }
+    }
+  }],
+  "receiver": [{
+    "stream_payload": {
+      "video": {
+        "frame_width": 1920,
+        "frame_height": 1080,
+        "frame_rate": { "numerator": 60, "denominator": 1 },
+        "pixel_format": "yuv422p10le",
+        "video_type": "rawvideo"
+      },
+      "audio": {
+        "channels": 2,
+        "sampleRate": 48000,
+        "format": "pcm_s24be",
+        "packetTime": "1ms"
+      }
+    },
+    "stream_type": {
+      "st2110": {
+        "transport": "st2110-20",
+        "payloadType" : 112
+      }
+    }
+  }]
+}
\ No newline at end of file
diff --git a/Development/nmos-cpp-node/intel-node-tx.json b/Development/nmos-cpp-node/intel-node-tx.json
new file mode 100644
index 0000000..f389a50
--- /dev/null
+++ b/Development/nmos-cpp-node/intel-node-tx.json
@@ -0,0 +1,66 @@
+{
+  "logging_level": 0,
+  "http_port": 90,
+  "label": "intel-broadcast-suite",
+  "senders": ["v"],
+  "senders_count": [1],
+  "receivers": ["v"],
+  "receivers_count": [0],
+  "device_tags": {
+    "pipeline": ["tx"]
+  },
+  "color_sampling": "YCbCr-4:2:2",
+  "function": "tx",
+  "gpu_hw_acceleration": "none",
+  "domain": "local",
+  "ffmpeg_grpc_server_address": "localhost",
+  "ffmpeg_grpc_server_port": "50051",
+  "sender_payload_type":112,
+  "frame_rate": { "numerator": 60000, "denominator": 1001 },
+  "sender": [{
+    "stream_payload": {
+      "video": {
+        "frame_width": 1920,
+        "frame_height": 1080,
+        "frame_rate": { "numerator": 60, "denominator": 1 },
+        "pixel_format": "yuv422p10le",
+        "video_type": "rawvideo"
+      },
+      "audio": {
+        "channels": 2,
+        "sampleRate": 48000,
+        "format": "pcm_s24be",
+        "packetTime": "1ms"
+      }
+    },
+    "stream_type": {
+      "st2110": {
+        "transport": "st2110-20",
+        "payloadType" : 112
+      }
+    }
+  }],
+  "receiver": [{
+    "stream_payload": {
+      "video": {
+        "frame_width": 1920,
+        "frame_height": 1080,
+        "frame_rate": { "numerator": 60, "denominator": 1 },
+        "pixel_format": "yuv422p10le",
+        "video_type": "rawvideo"
+      },
+      "audio": {
+        "channels": 2,
+        "sampleRate": 48000,
+        "format": "pcm_s24be",
+        "packetTime": "1ms"
+      }
+    },
+    "stream_type": {
+      "file": {
+        "path": "/root",
+        "filename": "1920x1080p10le_1.yuv"
+      }
+    }
+  }]
+}
\ No newline at end of file
diff --git a/Development/nmos-cpp-node/intel_config_parser.cpp b/Development/nmos-cpp-node/intel_config_parser.cpp
new file mode 100644
index 0000000..9b0a1c5
--- /dev/null
+++ b/Development/nmos-cpp-node/intel_config_parser.cpp
@@ -0,0 +1,145 @@
+#include "intel_config_parser.h"
+#include <cpprest/filestream.h>
+#include <iostream>
+#include <fstream>
+
+const Config& ConfigManager::get_config() const {
+    return config;
+}
+
+std::pair<int, int> ConfigManager::get_framerate(const Stream& stream) const {
+    return {stream.payload.video.frame_rate.numerator, stream.payload.video.frame_rate.denominator};
+}
+
+void ConfigManager::parse_json_file(const std::string& file_path) {
+    try {
+        // Open the file stream
+        std::ifstream file(file_path);
+        if (!file.is_open()) {
+            throw std::runtime_error("Could not open file");
+        }
+
+        // Read the file into a string
+        std::string json_str((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
+
+        // Parse the JSON string
+        web::json::value json_value = web::json::value::parse(json_str);
+
+        // Fill the Config struct
+        config.logging_level = json_value.at(U("logging_level")).as_integer();
+        config.function = json_value.at(U("function")).as_string();
+        config.gpu_hw_acceleration = json_value.at(U("gpu_hw_acceleration")).as_string();
+
+        for (const auto& sender : json_value.at(U("sender")).as_array()) {
+            std::cout<<"Sender: "<<std::endl;
+            config.senders.push_back(parse_stream(sender));
+        }
+
+        for (const auto& receiver : json_value.at(U("receiver")).as_array()) {
+            config.receivers.push_back(parse_stream(receiver));
+        }
+
+    } catch (const std::exception& e) {
+        std::cerr << "Error parsing JSON file: " << e.what() << std::endl;
+    }
+}
+
+void ConfigManager::print_config() const {
+    std::cout << "Logging Level: " << config.logging_level << std::endl;
+    std::cout << "Function: " << config.function << std::endl;
+    std::cout << "GPU HW Acceleration: " << config.gpu_hw_acceleration << std::endl;
+
+    for (const auto& sender : config.senders) {
+        std::cout << "Sender Video Frame Width: " << sender.payload.video.frame_width << std::endl;
+        std::cout << "Sender Video Frame Height: " << sender.payload.video.frame_height << std::endl;
+        std::cout << "Sender Video Frame Rate: " << sender.payload.video.frame_rate.numerator << "/" << sender.payload.video.frame_rate.denominator << std::endl;
+        std::cout << "Sender Video Pixel Format: " << sender.payload.video.pixel_format << std::endl;
+        std::cout << "Sender Video Type: " << sender.payload.video.video_type << std::endl;
+        if (sender.stream_type.type == stream_type::file) {
+            std::cout<<"Sender Stream type: File"<<std::endl;
+            std::cout << "|_ File Path: " << sender.stream_type.file.path << std::endl;
+            std::cout << "|_ File Name: " << sender.stream_type.file.filename << std::endl;
+        } else if (sender.stream_type.type == stream_type::st2110) {
+            std::cout<<"Sender Stream type: st2110"<<std::endl;
+            std::cout << "|_ Transport: " << sender.stream_type.st2110.transport << std::endl;
+            std::cout << "|_ Payload Type: " << sender.stream_type.st2110.payload_type << std::endl;
+        } else if (sender.stream_type.type == stream_type::mcm) {
+            std::cout<<"Sender Stream type: mcm"<<std::endl;
+            std::cout << "|_ Connection Type: " << sender.stream_type.mcm.conn_type << std::endl;
+            std::cout << "|_ Transport: " << sender.stream_type.mcm.transport << std::endl;
+            std::cout << "|_ URN: " << sender.stream_type.mcm.urn << std::endl;
+            std::cout << "|_ Transport Pixel Format: " << sender.stream_type.mcm.transport_pixel_format << std::endl;
+        }
+    }
+
+    for (const auto& receiver : config.receivers) {
+        std::cout << "Receiver Video Frame Width: " << receiver.payload.video.frame_width << std::endl;
+        std::cout << "Receiver Video Frame Height: " << receiver.payload.video.frame_height << std::endl;
+        std::cout << "Receiver Video Frame Rate: " << receiver.payload.video.frame_rate.numerator << "/" << receiver.payload.video.frame_rate.denominator << std::endl;
+        std::cout << "Receiver Video Pixel Format: " << receiver.payload.video.pixel_format << std::endl;
+        std::cout << "Receiver Video Type: " << receiver.payload.video.video_type << std::endl;
+        if (receiver.stream_type.type == stream_type::file) {
+            std::cout<<"Receiver Stream type: File"<<std::endl;
+            std::cout << "|_ File Path: " << receiver.stream_type.file.path << std::endl;
+            std::cout << "|_ File Name: " << receiver.stream_type.file.filename << std::endl;
+        } else if (receiver.stream_type.type == stream_type::st2110) {
+            std::cout<<"Receiver Stream type: st2110"<<std::endl;
+            std::cout << "|_ Transport: " << receiver.stream_type.st2110.transport << std::endl;
+            std::cout << "|_ Payload Type: " << receiver.stream_type.st2110.payload_type << std::endl;
+        } else if (receiver.stream_type.type == stream_type::mcm) {
+            std::cout<<"Receiver Stream type: mcm"<<std::endl;
+            std::cout << "|_ Connection Type: " << receiver.stream_type.mcm.conn_type << std::endl;
+            std::cout << "|_ Transport: " << receiver.stream_type.mcm.transport << std::endl;
+            std::cout << "|_ URN: " << receiver.stream_type.mcm.urn << std::endl;
+            std::cout << "|_ Transport Pixel Format: " << receiver.stream_type.mcm.transport_pixel_format << std::endl;
+        }
+    }
+}
+
+Video ConfigManager::parse_video(const web::json::value& video_data) const {
+    Video video;
+    video.frame_width = video_data.at(U("frame_width")).as_integer();
+    video.frame_height = video_data.at(U("frame_height")).as_integer();
+    video.frame_rate.numerator = video_data.at(U("frame_rate")).at(U("numerator")).as_integer();
+    video.frame_rate.denominator = video_data.at(U("frame_rate")).at(U("denominator")).as_integer();
+    video.pixel_format = video_data.at(U("pixel_format")).as_string();
+    video.video_type = video_data.at(U("video_type")).as_string();
+    return video;
+}
+
+Audio ConfigManager::parse_audio(const web::json::value& audio_data) const {
+    Audio audio;
+    audio.channels = audio_data.at(U("channels")).as_integer();
+    audio.sample_rate = audio_data.at(U("sampleRate")).as_integer();
+    audio.format = audio_data.at(U("format")).as_string();
+    audio.packet_time = audio_data.at(U("packetTime")).as_string();
+    return audio;
+}
+
+StreamType ConfigManager::parse_stream_type(const web::json::value& stream_type_data) const {
+    StreamType stream_type;
+    if (stream_type_data.has_field(U("file"))) {
+        stream_type.type = stream_type::file;
+        stream_type.file.path = stream_type_data.at(U("file")).at(U("path")).as_string();
+        stream_type.file.filename = stream_type_data.at(U("file")).at(U("filename")).as_string();
+    } else if (stream_type_data.has_field(U("st2110"))) {
+        stream_type.type = stream_type::st2110;
+        stream_type.st2110.transport = stream_type_data.at(U("st2110")).at(U("transport")).as_string();
+        stream_type.st2110.payload_type = stream_type_data.at(U("st2110")).at(U("payloadType")).as_integer();
+    } else if (stream_type_data.has_field(U("mcm"))) {
+        stream_type.type = stream_type::mcm;
+        stream_type.mcm.conn_type = stream_type_data.at(U("mcm")).at(U("conn_type")).as_string();
+        stream_type.mcm.transport = stream_type_data.at(U("mcm")).at(U("transport")).as_string();
+        stream_type.mcm.urn = stream_type_data.at(U("mcm")).at(U("urn")).as_string();
+        stream_type.mcm.transport_pixel_format = stream_type_data.at(U("mcm")).at(U("transportPixelFormat")).as_string();
+    }
+    return stream_type;
+}
+
+Stream ConfigManager::parse_stream(const web::json::value& stream_data) const {
+    Stream stream;
+    stream.payload.video = parse_video(stream_data.at(U("stream_payload")).at(U("video")));
+    stream.payload.audio = parse_audio(stream_data.at(U("stream_payload")).at(U("audio")));
+    stream.stream_type = parse_stream_type(stream_data.at(U("stream_type")));
+    return stream;
+}
\ No newline at end of file
diff --git a/Development/nmos-cpp-node/intel_config_parser.h b/Development/nmos-cpp-node/intel_config_parser.h
new file mode 100644
index 0000000..c490f38
--- /dev/null
+++ b/Development/nmos-cpp-node/intel_config_parser.h
@@ -0,0 +1,23 @@
+#ifndef INTEL_CONFIG_PARSER_H
+#define INTEL_CONFIG_PARSER_H
+
+#include <cpprest/json.h>
+#include "config_params.hpp"
+
+class ConfigManager {
+public:
+    ConfigManager() = default;
+    void parse_json_file(const std::string& file_path);
+    void print_config() const;
+    const Config& get_config() const;
+    std::pair<int, int> get_framerate(const Stream& stream) const;
+
+private:
+    Config config;
+    Video parse_video(const web::json::value& video_data) const;
+    Audio parse_audio(const web::json::value& audio_data) const;
+    StreamType parse_stream_type(const web::json::value& stream_type_data) const;
+    Stream parse_stream(const web::json::value& stream_data) const;
+};
+
+#endif // INTEL_CONFIG_PARSER_H
\ No newline at end of file
diff --git a/Development/nmos-cpp-node/main.cpp b/Development/nmos-cpp-node/main.cpp
index e4b420f..0e905fa 100644
--- a/Development/nmos-cpp-node/main.cpp
+++ b/Development/nmos-cpp-node/main.cpp
@@ -18,6 +18,10 @@
 #include "nmos/server.h"
 #include "nmos/server_utils.h" // for make_http_listener_config
 #include "node_implementation.h"
+// #include "config_params.hpp"
+
+#include "intel_config_parser.h"
+
 
 int main(int argc, char* argv[])
 {
@@ -33,6 +37,8 @@ int main(int argc, char* argv[])
     std::filebuf access_log_buf;
     std::ostream access_log(&access_log_buf);
 
+    ConfigManager config_manager;
+
     // Logging should all go through this logging gateway
     nmos::experimental::log_gate gate(error_log, access_log, log_model);
 
@@ -64,6 +70,9 @@ int main(int argc, char* argv[])
                 node_model.settings = web::json::value::parse(file);
                 node_model.settings.as_object();
             }
+            // Parse json to senders' and receivers' config
+            config_manager.parse_json_file(utility::s2us(argv[1]));
+            config_manager.print_config();
         }
 
         // Prepare run-time default settings (different than header defaults)
@@ -103,7 +112,7 @@ int main(int argc, char* argv[])
 
         // Set up the callbacks between the node server and the underlying implementation
 
-        auto node_implementation = make_node_implementation(node_model, gate);
+        auto node_implementation = make_node_implementation(node_model, config_manager, gate);
 
 // only implement communication with OCSP server if http_listener supports OCSP stapling
 // cf. preprocessor conditions in nmos::make_http_listener_config
@@ -116,28 +125,6 @@ int main(int argc, char* argv[])
         }
 #endif
 
-        // only configure communication with Authorization server if IS-10/BCP-003-02 is required
-        // Note:
-        // the validate_authorization callback must be set up before executing the make_node_server where make_node_api, make_connection_api, make_events_api, and make_channelmapping_api are set up
-        // the ws_validate_authorization callback must be set up before executing the make_node_server where make_events_ws_validate_handler is set up
-        // the get_authorization_bearer_token callback must be set up before executing the make_node_server where make_http_client_config is set up
-        nmos::experimental::authorization_state authorization_state;
-        if (nmos::experimental::fields::server_authorization(node_model.settings))
-        {
-            node_implementation
-                .on_validate_authorization(nmos::experimental::make_validate_authorization_handler(node_model, authorization_state, nmos::experimental::make_validate_authorization_token_handler(authorization_state, gate), gate))
-                .on_ws_validate_authorization(nmos::experimental::make_ws_validate_authorization_handler(node_model, authorization_state, nmos::experimental::make_validate_authorization_token_handler(authorization_state, gate), gate));
-        }
-        if (nmos::experimental::fields::client_authorization(node_model.settings))
-        {
-            node_implementation
-                .on_get_authorization_bearer_token(nmos::experimental::make_get_authorization_bearer_token_handler(authorization_state, gate))
-                .on_load_authorization_clients(nmos::experimental::make_load_authorization_clients_handler(node_model.settings, gate))
-                .on_save_authorization_client(nmos::experimental::make_save_authorization_client_handler(node_model.settings, gate))
-                .on_load_rsa_private_keys(nmos::make_load_rsa_private_keys_handler(node_model.settings, gate)) // may be omitted, only required for OAuth client which is using Private Key JWT as the requested authentication method for the token endpoint
-                .on_request_authorization_code(nmos::experimental::make_request_authorization_code_handler(gate)); // may be omitted, only required for OAuth client which is using the Authorization Code Flow to obtain the access token
-        }
-
         nmos::experimental::control_protocol_state control_protocol_state(node_implementation.control_protocol_property_changed);
         if (0 <= nmos::fields::control_protocol_ws_port(node_model.settings))
         {
@@ -153,69 +140,7 @@ int main(int argc, char* argv[])
 
         // Add the underlying implementation, which will set up the node resources, etc.
 
-        node_server.thread_functions.push_back([&] { node_implementation_thread(node_model, control_protocol_state, gate); });
-
-// only implement communication with OCSP server if http_listener supports OCSP stapling
-// cf. preprocessor conditions in nmos::make_http_listener_config
-#if !defined(_WIN32) || defined(CPPREST_FORCE_HTTP_LISTENER_ASIO)
-        if (nmos::experimental::fields::server_secure(node_model.settings))
-        {
-            auto load_ca_certificates = node_implementation.load_ca_certificates;
-            auto load_server_certificates = node_implementation.load_server_certificates;
-            node_server.thread_functions.push_back([&, load_ca_certificates, load_server_certificates] { nmos::ocsp_behaviour_thread(node_model, ocsp_state, load_ca_certificates, load_server_certificates, gate); });
-        }
-#endif
-
-        // only configure communication with Authorization server if IS-10/BCP-003-02 is required
-        if (nmos::experimental::fields::client_authorization(node_model.settings))
-        {
-            std::map<nmos::host_port, web::http::experimental::listener::api_router> api_routers;
-
-            // Configure the authorization_redirect API (require for Authorization Code Flow support)
-
-            if (web::http::oauth2::experimental::grant_types::authorization_code.name == nmos::experimental::fields::authorization_flow(node_model.settings))
-            {
-                auto load_ca_certificates = node_implementation.load_ca_certificates;
-                auto load_rsa_private_keys = node_implementation.load_rsa_private_keys;
-                api_routers[{ {}, nmos::experimental::fields::authorization_redirect_port(node_model.settings) }].mount({}, nmos::experimental::make_authorization_redirect_api(node_model, authorization_state, load_ca_certificates, load_rsa_private_keys, gate));
-            }
-
-            // Configure the jwks_uri API (require for Private Key JWK support)
-
-            if (web::http::oauth2::experimental::token_endpoint_auth_methods::private_key_jwt.name == nmos::experimental::fields::token_endpoint_auth_method(node_model.settings))
-            {
-                auto load_rsa_private_keys = node_implementation.load_rsa_private_keys;
-                api_routers[{ {}, nmos::experimental::fields::jwks_uri_port(node_model.settings) }].mount({}, nmos::experimental::make_jwk_uri_api(node_model, load_rsa_private_keys, gate));
-            }
-
-            auto http_config = nmos::make_http_listener_config(node_model.settings, node_implementation.load_server_certificates, node_implementation.load_dh_param, node_implementation.get_ocsp_response, gate);
-            const auto server_secure = nmos::experimental::fields::server_secure(node_model.settings);
-            const auto hsts = nmos::experimental::get_hsts(node_model.settings);
-            for (auto& api_router : api_routers)
-            {
-                auto found = node_server.api_routers.find(api_router.first);
-
-                const auto& host = !api_router.first.first.empty() ? api_router.first.first : web::http::experimental::listener::host_wildcard;
-                const auto& port = nmos::experimental::server_port(api_router.first.second, node_model.settings);
-
-                if (node_server.api_routers.end() != found)
-                {
-                    const auto uri = web::http::experimental::listener::make_listener_uri(server_secure, host, port);
-                    auto listener = std::find_if(node_server.http_listeners.begin(), node_server.http_listeners.end(), [&](const web::http::experimental::listener::http_listener& listener) { return listener.uri() == uri; });
-                    if (node_server.http_listeners.end() != listener)
-                    {
-                        found->second.pop_back(); // remove the api_finally_handler which was previously added in the make_node_server, the api_finally_handler will be re-inserted in the make_api_listener
-                        node_server.http_listeners.erase(listener);
-                    }
-                    found->second.mount({}, api_router.second);
-                    node_server.http_listeners.push_back(nmos::make_api_listener(server_secure, host, port, found->second, http_config, hsts, gate));
-                }
-                else
-                {
-                    node_server.http_listeners.push_back(nmos::make_api_listener(server_secure, host, port, api_router.second, http_config, hsts, gate));
-                }
-            }
-        }
+        node_server.thread_functions.push_back([&] { node_implementation_thread(node_model, control_protocol_state, config_manager, gate); });
 
         if (!nmos::experimental::fields::http_trace(node_model.settings))
         {
@@ -227,29 +152,6 @@ int main(int argc, char* argv[])
             }
         }
 
-        // only configure communication with Authorization server if IS-10/BCP-003-02 is required
-        if (nmos::experimental::fields::client_authorization(node_model.settings) || nmos::experimental::fields::server_authorization(node_model.settings))
-        {
-            // IS-10 client registration, fetch access token, and fetch authorization server token public key
-            // see https://specs.amwa.tv/is-10/releases/v1.0.0/docs/4.2._Behaviour_-_Clients.html
-            // and https://specs.amwa.tv/is-10/releases/v1.0.0/docs/4.5._Behaviour_-_Resource_Servers.html#public-keys
-            auto load_ca_certificates = node_implementation.load_ca_certificates;
-            auto load_rsa_private_keys = node_implementation.load_rsa_private_keys;
-            auto load_authorization_clients = node_implementation.load_authorization_clients;
-            auto save_authorization_client = node_implementation.save_authorization_client;
-            auto request_authorization_code = node_implementation.request_authorization_code;
-            node_server.thread_functions.push_back([&, load_ca_certificates, load_rsa_private_keys, load_authorization_clients, save_authorization_client, request_authorization_code] { nmos::experimental::authorization_behaviour_thread(node_model, authorization_state, load_ca_certificates, load_rsa_private_keys, load_authorization_clients, save_authorization_client, request_authorization_code, gate); });
-
-            if (nmos::experimental::fields::server_authorization(node_model.settings))
-            {
-                // When no matching public key for a given access token, it SHOULD attempt to obtain the missing public key
-                // via the the token iss claim as specified in RFC 8414 section 3.
-                // see https://tools.ietf.org/html/rfc8414#section-3
-                // and https://specs.amwa.tv/is-10/releases/v1.0.0/docs/4.5._Behaviour_-_Resource_Servers.html#public-keys
-                node_server.thread_functions.push_back([&, load_ca_certificates] { nmos::experimental::authorization_token_issuer_thread(node_model, authorization_state, load_ca_certificates, gate); });
-            }
-        }
-
         // Open the API ports and start up node operation (including the DNS-SD advertisements)
 
         slog::log<slog::severities::info>(gate, SLOG_FLF) << "Preparing for connections";
diff --git a/Development/nmos-cpp-node/node_implementation.cpp b/Development/nmos-cpp-node/node_implementation.cpp
index f12cca1..00722e7 100644
--- a/Development/nmos-cpp-node/node_implementation.cpp
+++ b/Development/nmos-cpp-node/node_implementation.cpp
@@ -1,3 +1,9 @@
+#include <iostream>
+#include <cstdlib>
+#include <thread>
+#include <unordered_map>
+#include <algorithm>
+
 #include "node_implementation.h"
 
 #include <boost/range/adaptor/filtered.hpp>
@@ -49,7 +55,49 @@
 #include "nmos/video_jxsv.h"
 #include "sdp/sdp.h"
 
-// example node implementation details
+#include "FFmpeg_wrapper_client.h"
+
+namespace tracker{
+    std::unordered_map<nmos::id, Stream> resource_stream_map;
+    Stream get_stream_info(const nmos::id& resource_id) {
+        auto it = resource_stream_map.find(resource_id);
+        if (it != resource_stream_map.end()) {
+            return it->second;
+        }
+        throw std::runtime_error("Resource ID not found");
+    }
+    void add_stream_info(const nmos::id& resource_id, const Stream& stream_info) {
+        resource_stream_map.emplace(resource_id, stream_info);
+    }
+
+    std::vector<Stream> get_file_streams_receivers(const Config& config) {
+        std::vector<Stream> file_streams;
+        std::copy_if(config.receivers.begin(), config.receivers.end(), std::back_inserter(file_streams), [](const Stream& stream) {
+            return stream.stream_type.type == stream_type::file;
+        });
+        return file_streams;
+    }
+
+    std::vector<Stream> get_file_streams_senders(const Config& config) {
+        std::vector<Stream> file_streams;
+        std::copy_if(config.senders.begin(), config.senders.end(), std::back_inserter(file_streams), [](const Stream& stream) {
+            return stream.stream_type.type == stream_type::file;
+        });
+        return file_streams;
+    }
+}
+
+
+
+namespace grpc {
+// Function to execute the grpc client logic for ffmpeg
+void sendDataToFfmpeg(const std::string& interface, const std::string& port, const Config &configParams) {
+    CmdPassClient obj(interface, port);
+    std::vector<std::pair<std::string,std::string>> commitedConfigs = commitConfigs(configParams);
+    obj.FFmpegCmdExec(commitedConfigs);
+}
+} // namespace grpc
+
 namespace impl
 {
     // custom logging category for the example node implementation thread
@@ -71,9 +119,6 @@ namespace impl
         const web::json::field_as_value_or node_tags{ U("node_tags"), web::json::value::object() };
         const web::json::field_as_value_or device_tags{ U("device_tags"), web::json::value::object() };
 
-        // how_many: provides for very basic testing of a node with many sub-resources of each type
-        const web::json::field_as_integer_or how_many{ U("how_many"), 1 };
-
         // activate_senders: controls whether to activate senders on start up (true, default) or not (false)
         const web::json::field_as_bool_or activate_senders{ U("activate_senders"), true };
 
@@ -83,19 +128,35 @@ namespace impl
         const web::json::field_as_value_or senders{ U("senders"), {} };
         const web::json::field_as_value_or receivers{ U("receivers"), {} };
 
-        // frame_rate: controls the grain_rate of video, audio and ancillary data sources and flows
-        // and the equivalent parameter constraint on video receivers
-        // the value must be an object like { "numerator": 25, "denominator": 1 }
-        // hm, unfortunately can't use nmos::make_rational(nmos::rates::rate25) during static initialization
+        const web::json::field_as_array sender{ U("sender") };
+        const web::json::field_as_array receiver{ U("receiver") };
+
+        // coresponding arrays for senders, receivers that provide count by type of port.
+        // example: for senders: ["v", "a", "d"], the senders_count: [3, 1, 1] should be defined.
+        // it means that there are 3 senders of type video, 1 sender of type audio and 1 sender of type data
+        const web::json::field_as_value_or senders_count{ U("senders_count"), {} };
+        const web::json::field_as_value_or receivers_count{ U("receivers_count"), {} };
+
+        // sender_payload_type, receiver_payload_type: controls the payload_type of senders and receivers
+        // TODO: change the reference to Config by stream sender or receiver
+        const web::json::field_as_integer_or sender_payload_type{ U("sender_payload_type"), 112 };
+        const web::json::field_as_integer_or receiver_payload_type{ U("receiver_payload_type"), 112 };
+
+        // IP address and port to connect to ffmpeg grpc service in order to pass properties when another NMOS node
+        // is connected to this NMOS node for BCS pipeline
+        const web::json::field_as_string_or ffmpeg_grpc_server_address{ U("ffmpeg_grpc_server_address"), "localhost"};
+        const web::json::field_as_string_or ffmpeg_grpc_server_port{ U("ffmpeg_grpc_server_port"), "50051"};
+
         const web::json::field_as_value_or frame_rate{ U("frame_rate"), web::json::value_of({
             { nmos::fields::numerator, 25 },
             { nmos::fields::denominator, 1 }
         }) };
 
-        // frame_width, frame_height: control the frame_width and frame_height of video flows
+         // frame_width, frame_height: control the frame_width and frame_height of video flows
         const web::json::field_as_integer_or frame_width{ U("frame_width"), 1920 };
         const web::json::field_as_integer_or frame_height{ U("frame_height"), 1080 };
 
+        // In curret use case, below params are default values
         // interlace_mode: controls the interlace_mode of video flows, see nmos::interlace_mode
         // when omitted, a default of "progressive" or "interlaced_tff" is used based on the frame_rate, etc.
         const web::json::field_as_string interlace_mode{ U("interlace_mode") };
@@ -122,7 +183,7 @@ namespace impl
         const web::json::field_as_bool_or smpte2022_7{ U("smpte2022_7"), true };
     }
 
-    nmos::interlace_mode get_interlace_mode(const nmos::settings& settings);
+    nmos::interlace_mode get_interlace_mode(const nmos::rational& frame_rate, uint32_t frame_height, const nmos::settings& settings);
 
     // the different kinds of 'port' (standing for the format/media type/event type) implemented by the example node
     // each 'port' of the example node has a source, flow, sender and/or compatible receiver
@@ -155,6 +216,7 @@ namespace impl
     bool is_rtp_port(const port& port);
     bool is_ws_port(const port& port);
     std::vector<port> parse_ports(const web::json::value& value);
+    std::vector<int> parse_count(const web::json::value& value);
 
     const std::vector<nmos::channel> channels_repeat{
         { U("Left Channel"), nmos::channel_symbols::L },
@@ -191,23 +253,23 @@ namespace impl
 }
 
 // forward declarations for node_implementation_thread
-void node_implementation_init(nmos::node_model& model, nmos::experimental::control_protocol_state& control_protocol_state, slog::base_gate& gate);
+void node_implementation_init(nmos::node_model& model, nmos::experimental::control_protocol_state& control_protocol_state, ConfigManager& config_manager, slog::base_gate& gate);
 void node_implementation_run(nmos::node_model& model, slog::base_gate& gate);
-nmos::connection_resource_auto_resolver make_node_implementation_auto_resolver(const nmos::settings& settings);
-nmos::connection_sender_transportfile_setter make_node_implementation_transportfile_setter(const nmos::resources& node_resources, const nmos::settings& settings);
+nmos::connection_resource_auto_resolver make_node_implementation_auto_resolver(const nmos::settings& settings, slog::base_gate& gate);
+nmos::connection_sender_transportfile_setter make_node_implementation_transportfile_setter(const nmos::resources& node_resources, const nmos::settings& settings, slog::base_gate& gate);
 
 struct node_implementation_init_exception {};
 
 // This is an example of how to integrate the nmos-cpp library with a device-specific underlying implementation.
 // It constructs and inserts a node resource and some sub-resources into the model, based on the model settings,
 // starts background tasks to emit regular events from the temperature event source, and then waits for shutdown.
-void node_implementation_thread(nmos::node_model& model, nmos::experimental::control_protocol_state& control_protocol_state, slog::base_gate& gate_)
+void node_implementation_thread(nmos::node_model& model, nmos::experimental::control_protocol_state& control_protocol_state, ConfigManager& config_manager, slog::base_gate& gate_)
 {
     nmos::details::omanip_gate gate{ gate_, nmos::stash_category(impl::categories::node_implementation) };
 
     try
     {
-        node_implementation_init(model, control_protocol_state, gate);
+        node_implementation_init(model, control_protocol_state, config_manager, gate);
         node_implementation_run(model, gate);
     }
     catch (const node_implementation_init_exception&)
@@ -237,7 +299,7 @@ void node_implementation_thread(nmos::node_model& model, nmos::experimental::con
     }
 }
 
-void node_implementation_init(nmos::node_model& model, nmos::experimental::control_protocol_state& control_protocol_state, slog::base_gate& gate)
+void node_implementation_init(nmos::node_model& model, nmos::experimental::control_protocol_state& control_protocol_state, ConfigManager& config_manager, slog::base_gate& gate)
 {
     using web::json::value;
     using web::json::value_from_elements;
@@ -248,29 +310,46 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
     const auto seed_id = nmos::experimental::fields::seed_id(model.settings);
     const auto node_id = impl::make_id(seed_id, nmos::types::node);
     const auto device_id = impl::make_id(seed_id, nmos::types::device);
-    const auto how_many = impl::fields::how_many(model.settings);
+
+    const auto ffmpeg_grpc_server_address = impl::fields::ffmpeg_grpc_server_address(model.settings);
+    const auto ffmpeg_grpc_server_port = impl::fields::ffmpeg_grpc_server_port(model.settings);
+    //seder payload is right know global for all senders
+    const auto sender_payload_type = impl::fields::sender_payload_type(model.settings);
+
+    auto configIntel = config_manager.get_config();
+    auto sender_arr_length = configIntel.senders.size();
+    auto sender_arr = configIntel.senders;
+    auto receiver_arr_length = configIntel.receivers.size();
+    auto receiver_arr = configIntel.receivers;
+
+    //change
+    const auto senders_count = impl::parse_count(impl::fields::senders_count(model.settings)); // max count of elements = 4 (because 4 types of ports: video, audio, mux, data)
+    const auto senders_count_total = std::accumulate(senders_count.begin(), senders_count.end(), 0);
+    //change
+    const auto receivers_count = impl::parse_count(impl::fields::receivers_count(model.settings)); // max count of elements = 4 (because 4 types of ports: video, audio, mux, data)
+    const auto receivers_count_total = std::accumulate(receivers_count.begin(), receivers_count.end(), 0);
     const auto sender_ports = impl::parse_ports(impl::fields::senders(model.settings));
     const auto rtp_sender_ports = boost::copy_range<std::vector<impl::port>>(sender_ports | boost::adaptors::filtered(impl::is_rtp_port));
     const auto ws_sender_ports = boost::copy_range<std::vector<impl::port>>(sender_ports | boost::adaptors::filtered(impl::is_ws_port));
     const auto receiver_ports = impl::parse_ports(impl::fields::receivers(model.settings));
     const auto rtp_receiver_ports = boost::copy_range<std::vector<impl::port>>(receiver_ports | boost::adaptors::filtered(impl::is_rtp_port));
     const auto ws_receiver_ports = boost::copy_range<std::vector<impl::port>>(receiver_ports | boost::adaptors::filtered(impl::is_ws_port));
+
+    //generic values for whole node
+    // const auto interlace_mode = impl::get_interlace_mode(model.settings);
     const auto frame_rate = nmos::parse_rational(impl::fields::frame_rate(model.settings));
-    const auto frame_width = impl::fields::frame_width(model.settings);
-    const auto frame_height = impl::fields::frame_height(model.settings);
-    const auto interlace_mode = impl::get_interlace_mode(model.settings);
     const auto colorspace = nmos::colorspace{ impl::fields::colorspace(model.settings) };
     const auto transfer_characteristic = nmos::transfer_characteristic{ impl::fields::transfer_characteristic(model.settings) };
     const auto sampling = sdp::sampling{ impl::fields::color_sampling(model.settings) };
     const auto bit_depth = impl::fields::component_depth(model.settings);
-    const auto video_type = nmos::media_type{ impl::fields::video_type(model.settings) };
+    // const auto video_type = nmos::media_type{ impl::fields::video_type(model.settings) };
     const auto channel_count = impl::fields::channel_count(model.settings);
     const auto smpte2022_7 = impl::fields::smpte2022_7(model.settings);
 
     // for now, some typical values for video/jxsv, based on VSF TR-08:2022
     // see https://vsf.tv/download/technical_recommendations/VSF_TR-08_2022-04-20.pdf
     const auto profile = nmos::profiles::High444_12;
-    const auto level = nmos::get_video_jxsv_level(frame_rate, frame_width, frame_height);
+    // const auto level = nmos::get_video_jxsv_level(frame_rate, frame_width, frame_height);
     const auto sublevel = nmos::sublevels::Sublev3bpp;
     const auto max_bits_per_pixel = 4.0; // min coding efficiency
     const auto bits_per_pixel = 2.0;
@@ -279,6 +358,15 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
     // any delay between updates to the model resources is unnecessary unless for debugging purposes
     const unsigned int delay_millis{ 0 };
 
+    if (senders_count.size() != sender_ports.size()){
+        slog::log<slog::severities::severe>(gate, SLOG_FLF) << "the length of arrays of senders and senders_count differs. Check JSON configuration";
+        throw node_implementation_init_exception();
+    }
+    if (receivers_count.size() != receiver_ports.size()){
+        slog::log<slog::severities::severe>(gate, SLOG_FLF) << "the length of arrays of receivers and receivers_count differs. Check JSON configuration";
+        throw node_implementation_init_exception();
+    }
+
     // it is important that the model be locked before inserting, updating or deleting a resource
     // and that the the node behaviour thread be notified after doing so
     const auto insert_resource_after = [&model, &lock](unsigned int milliseconds, nmos::resources& resources, nmos::resource&& resource, slog::base_gate& gate)
@@ -293,42 +381,20 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
         else
             slog::log<slog::severities::severe>(gate, SLOG_FLF) << "Model update error: " << id_type;
 
-        slog::log<slog::severities::too_much_info>(gate, SLOG_FLF) << "Notifying node behaviour thread"; // and anyone else who cares...
+        slog::log<slog::severities::too_much_info>(gate, SLOG_FLF) << "Notifying node behaviour thread";
         model.notify();
 
         return success;
     };
 
-    // it is important that the model be locked before inserting, updating or deleting a resource
-    // and that the the node behaviour thread be notified after doing so
-    const auto insert_root_after = [&model, insert_resource_after](unsigned int milliseconds, nmos::control_protocol_resource& root, slog::base_gate& gate)
-    {
-        std::function<void(nmos::resources& resources, nmos::control_protocol_resource& resource)> insert_resources;
-
-        insert_resources = [&milliseconds, insert_resource_after, &insert_resources, &gate](nmos::resources& resources, nmos::control_protocol_resource& resource)
-        {
-            for (auto& resource_ : resource.resources)
-            {
-                insert_resources(resources, resource_);
-                if (!insert_resource_after(milliseconds, resources, std::move(resource_), gate)) throw node_implementation_init_exception();
-            }
-        };
-
-        auto& resources = model.control_protocol_resources;
-
-        insert_resources(resources, root);
-        if (!insert_resource_after(milliseconds, resources, std::move(root), gate)) throw node_implementation_init_exception();
-    };
-
-    const auto resolve_auto = make_node_implementation_auto_resolver(model.settings);
-    const auto set_transportfile = make_node_implementation_transportfile_setter(model.node_resources, model.settings);
+    const auto resolve_auto = make_node_implementation_auto_resolver(model.settings, gate);
+    const auto set_transportfile = make_node_implementation_transportfile_setter(model.node_resources, model.settings, gate);
 
     const auto clocks = web::json::value_of({ nmos::make_internal_clock(nmos::clock_names::clk0) });
     // filter network interfaces to those that correspond to the specified host_addresses
     const auto host_interfaces = nmos::get_host_interfaces(model.settings);
     const auto interfaces = nmos::experimental::node_interfaces(host_interfaces);
 
-    // example node
     {
         auto node = nmos::make_node(node_id, clocks, nmos::make_node_interfaces(interfaces), model.settings);
         node.data[nmos::fields::tags] = impl::fields::node_tags(model.settings);
@@ -352,7 +418,7 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
         slog::log<slog::severities::severe>(gate, SLOG_FLF) << "No network interface corresponding to host_address?";
         throw node_implementation_init_exception();
     }
-    const auto& host_interface = *host_interface_;
+    // const auto& host_interface = *host_interface_;
     // hmm, should probably add a custom setting to control the primary and secondary interfaces for the example node's RTP senders and receivers
     // rather than just picking the one(s) corresponding to the first and last of the specified host addresses
     const auto& primary_address = model.settings.has_field(nmos::fields::host_addresses) ? web::json::front(nmos::fields::host_addresses(model.settings)).as_string() : host_address;
@@ -369,47 +435,74 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
     const auto interface_names = smpte2022_7
         ? std::vector<utility::string_t>{ primary_interface.name, secondary_interface.name }
         : std::vector<utility::string_t>{ primary_interface.name };
-
-    // example device
     {
-        auto sender_ids = impl::make_ids(seed_id, nmos::types::sender, rtp_sender_ports, how_many);
-        if (0 <= nmos::fields::events_port(model.settings)) boost::range::push_back(sender_ids, impl::make_ids(seed_id, nmos::types::sender, ws_sender_ports, how_many));
-        auto receiver_ids = impl::make_ids(seed_id, nmos::types::receiver, receiver_ports, how_many);
+        // For simplified NMOS and BCS needs, only one device = pipeline is required.
+        slog::log<slog::severities::info>(gate, SLOG_FLF) << "DEVICE";
+        auto sender_ids = impl::make_ids(seed_id, nmos::types::sender, rtp_sender_ports, senders_count_total);
+        slog::log<slog::severities::info>(gate, SLOG_FLF) << "SENDERS_TOTAL = " << senders_count_total;
+        slog::log<slog::severities::info>(gate, SLOG_FLF) << "RECEIVERS_TOTAL = " << receivers_count_total;
+
+        if (0 <= nmos::fields::events_port(model.settings)) boost::range::push_back(sender_ids, impl::make_ids(seed_id, nmos::types::sender, ws_sender_ports, senders_count_total));
+        auto receiver_ids = impl::make_ids(seed_id, nmos::types::receiver, receiver_ports, receivers_count_total);
         auto device = nmos::make_device(device_id, node_id, sender_ids, receiver_ids, model.settings);
         device.data[nmos::fields::tags] = impl::fields::device_tags(model.settings);
         if (!insert_resource_after(delay_millis, model.node_resources, std::move(device), gate)) throw node_implementation_init_exception();
     }
 
-    // example sources, flows and senders
-    for (int index = 0; index < how_many; ++index)
+    for (const auto& port : rtp_sender_ports)
     {
-        for (const auto& port : rtp_sender_ports)
+        // senders_count[senders_iterator] is the total count of senders by port type - video/audio/data/mux
+        // Change to length of sender array instaed of sender_count
+        for (int index = 0; index < sender_arr_length; ++index)
         {
             const auto source_id = impl::make_id(seed_id, nmos::types::source, port, index);
             const auto flow_id = impl::make_id(seed_id, nmos::types::flow, port, index);
             const auto sender_id = impl::make_id(seed_id, nmos::types::sender, port, index);
 
+            auto senderDefinition = configIntel.senders[index];
+
+            const auto frame_rate_json_format = web::json::value_of({
+                { nmos::fields::numerator, config_manager.get_framerate(senderDefinition).first },
+                { nmos::fields::denominator, config_manager.get_framerate(senderDefinition).second }
+            });
+
+            const auto frame_rate_parsed_rational = nmos::parse_rational(frame_rate_json_format);
+            const auto frame_w = senderDefinition.payload.video.frame_width;
+            const auto frame_h = senderDefinition.payload.video.frame_height;
+            const auto level = nmos::get_video_jxsv_level(frame_rate_parsed_rational, frame_w, frame_h);
+            const auto tx_interlace_mode = impl::get_interlace_mode(frame_rate_parsed_rational, frame_h, model.settings);
+
+            nmos::media_type video_type;
+            if (senderDefinition.payload.video.video_type == "rawvideo") {
+                video_type = nmos::media_types::video_raw;
+            } else if (senderDefinition.payload.video.video_type == "jxsv") {
+                video_type = nmos::media_types::video_jxsv;
+            } else {
+                // https://specs.amwa.tv/is-04/releases/v1.2.0/APIs/schemas/with-refs/flow_video_coded.html
+                video_type = nmos::media_type{utility::s2us(senderDefinition.payload.video.video_type)};
+            }
+
             nmos::resource source;
             if (impl::ports::video == port)
             {
-                source = nmos::make_video_source(source_id, device_id, nmos::clock_names::clk0, frame_rate, model.settings);
+                source = nmos::make_video_source(source_id, device_id, nmos::clock_names::clk0, frame_rate_parsed_rational, model.settings);
             }
-            else if (impl::ports::audio == port)
+            else if (impl::ports::audio == port) // not yet supported or add to release notes
             {
                 const auto channels = boost::copy_range<std::vector<nmos::channel>>(boost::irange(0, channel_count) | boost::adaptors::transformed([&](const int& index)
                 {
                     return impl::channels_repeat[index % (int)impl::channels_repeat.size()];
                 }));
 
-                source = nmos::make_audio_source(source_id, device_id, nmos::clock_names::clk0, frame_rate, channels, model.settings);
+                source = nmos::make_audio_source(source_id, device_id, nmos::clock_names::clk0, frame_rate_parsed_rational, channels, model.settings);
             }
-            else if (impl::ports::data == port)
+            else if (impl::ports::data == port) // not yet supported
             {
-                source = nmos::make_data_source(source_id, device_id, nmos::clock_names::clk0, frame_rate, model.settings);
+                source = nmos::make_data_source(source_id, device_id, nmos::clock_names::clk0, frame_rate_parsed_rational, model.settings);
             }
-            else if (impl::ports::mux == port)
+            else if (impl::ports::mux == port) // not yet supported
             {
-                source = nmos::make_mux_source(source_id, device_id, nmos::clock_names::clk0, frame_rate, model.settings);
+                source = nmos::make_mux_source(source_id, device_id, nmos::clock_names::clk0, frame_rate_parsed_rational, model.settings);
             }
             impl::insert_parents(source, seed_id, port, index);
             impl::set_label_description(source, port, index);
@@ -421,8 +514,8 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
                 {
                     flow = nmos::make_raw_video_flow(
                         flow_id, source_id, device_id,
-                        frame_rate,
-                        frame_width, frame_height, interlace_mode,
+                        frame_rate_parsed_rational,
+                        frame_w, frame_h, tx_interlace_mode,
                         colorspace, transfer_characteristic, sampling, bit_depth,
                         model.settings
                     );
@@ -431,8 +524,8 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
                 {
                     flow = nmos::make_video_jxsv_flow(
                         flow_id, source_id, device_id,
-                        frame_rate,
-                        frame_width, frame_height, interlace_mode,
+                        frame_rate_parsed_rational,
+                        frame_w, frame_h, tx_interlace_mode,
                         colorspace, transfer_characteristic, sampling, bit_depth,
                         profile, level, sublevel, bits_per_pixel,
                         model.settings
@@ -442,8 +535,8 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
                 {
                     flow = nmos::make_coded_video_flow(
                         flow_id, source_id, device_id,
-                        frame_rate,
-                        frame_width, frame_height, interlace_mode,
+                        frame_rate_parsed_rational,
+                        frame_w, frame_h, tx_interlace_mode,
                         colorspace, transfer_characteristic, sampling, bit_depth,
                         video_type,
                         model.settings
@@ -454,20 +547,20 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
             {
                 flow = nmos::make_raw_audio_flow(flow_id, source_id, device_id, 48000, 24, model.settings);
                 // add optional grain_rate
-                flow.data[nmos::fields::grain_rate] = nmos::make_rational(frame_rate);
+                flow.data[nmos::fields::grain_rate] = nmos::make_rational(frame_rate_parsed_rational);
             }
             else if (impl::ports::data == port)
             {
                 nmos::did_sdid timecode{ 0x60, 0x60 };
                 flow = nmos::make_sdianc_data_flow(flow_id, source_id, device_id, { timecode }, model.settings);
                 // add optional grain_rate
-                flow.data[nmos::fields::grain_rate] = nmos::make_rational(frame_rate);
+                flow.data[nmos::fields::grain_rate] = nmos::make_rational(frame_rate_parsed_rational);
             }
             else if (impl::ports::mux == port)
             {
                 flow = nmos::make_mux_flow(flow_id, source_id, device_id, model.settings);
                 // add optional grain_rate
-                flow.data[nmos::fields::grain_rate] = nmos::make_rational(frame_rate);
+                flow.data[nmos::fields::grain_rate] = nmos::make_rational(frame_rate_parsed_rational);
             }
             impl::insert_parents(flow, seed_id, port, index);
             impl::set_label_description(flow, port, index);
@@ -478,12 +571,13 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
 
             const auto manifest_href = nmos::experimental::make_manifest_api_manifest(sender_id, model.settings);
             auto sender = nmos::make_sender(sender_id, flow_id, nmos::transports::rtp, device_id, manifest_href.to_string(), interface_names, model.settings);
+            tracker::add_stream_info(sender_id,senderDefinition);
             // hm, could add nmos::make_video_jxsv_sender to encapsulate this?
             if (impl::ports::video == port && nmos::media_types::video_jxsv == video_type)
             {
                 // additional attributes required by BCP-006-01
                 // see https://specs.amwa.tv/bcp-006-01/branches/v1.0-dev/docs/NMOS_With_JPEG_XS.html#senders
-                const auto format_bit_rate = nmos::get_video_jxsv_bit_rate(frame_rate, frame_width, frame_height, bits_per_pixel);
+                const auto format_bit_rate = nmos::get_video_jxsv_bit_rate(frame_rate_parsed_rational, frame_w, frame_h, bits_per_pixel);
                 // round to nearest Megabit/second per examples in VSF TR-08:2022
                 const auto transport_bit_rate = uint64_t(transport_bit_rate_factor * format_bit_rate / 1e3 + 0.5) * 1000;
                 sender.data[nmos::fields::bit_rate] = value(transport_bit_rate);
@@ -518,30 +612,47 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
         }
     }
 
-    // example receivers
-    for (int index = 0; index < how_many; ++index)
-    {
-        for (const auto& port : rtp_receiver_ports)
-        {
+    for (const auto& port : rtp_receiver_ports) {
+        for (int index = 0; index < receiver_arr_length; ++index){
             const auto receiver_id = impl::make_id(seed_id, nmos::types::receiver, port, index);
-
+            auto configIntel = config_manager.get_config();
+            auto receiverDefinition = configIntel.receivers[index];
+            const auto rx_frame_rate_json_format = web::json::value_of({
+                { nmos::fields::numerator, config_manager.get_framerate(receiverDefinition).first },
+                { nmos::fields::denominator, config_manager.get_framerate(receiverDefinition).second }
+            });
+            const auto rx_frame_rate_parsed_rational = nmos::parse_rational(rx_frame_rate_json_format);
+            const auto frame_w_r = receiverDefinition.payload.video.frame_width;
+            const auto frame_h_r = receiverDefinition.payload.video.frame_height;
+            const auto level = nmos::get_video_jxsv_level(rx_frame_rate_parsed_rational, frame_w_r, frame_h_r);
+            const auto rx_interlace_mode = impl::get_interlace_mode(rx_frame_rate_parsed_rational, frame_h_r, model.settings);
+            nmos::media_type video_type;
+            if (receiverDefinition.payload.video.video_type == "rawvideo") {
+                video_type = nmos::media_types::video_raw;
+            } else if (receiverDefinition.payload.video.video_type == "jxsv") {
+                video_type = nmos::media_types::video_jxsv;
+            } else {
+                // https://specs.amwa.tv/is-04/releases/v1.2.0/APIs/schemas/with-refs/flow_video_coded.html
+                video_type = nmos::media_type{utility::s2us(receiverDefinition.payload.video.video_type)};
+            }
             nmos::resource receiver;
             if (impl::ports::video == port)
             {
                 receiver = nmos::make_receiver(receiver_id, device_id, nmos::transports::rtp, interface_names, nmos::formats::video, { video_type }, model.settings);
+                tracker::add_stream_info(receiver_id, receiverDefinition);
                 // add an example constraint set; these should be completed fully!
                 if (nmos::media_types::video_raw == video_type)
                 {
-                    const auto interlace_modes = nmos::interlace_modes::progressive != interlace_mode
+                    const auto interlace_modes = nmos::interlace_modes::progressive != rx_interlace_mode
                         ? std::vector<utility::string_t>{ nmos::interlace_modes::interlaced_bff.name, nmos::interlace_modes::interlaced_tff.name, nmos::interlace_modes::interlaced_psf.name }
                         : std::vector<utility::string_t>{ nmos::interlace_modes::progressive.name };
                     receiver.data[nmos::fields::caps][nmos::fields::constraint_sets] = value_of({
                         value_of({
-                            { nmos::caps::format::grain_rate, nmos::make_caps_rational_constraint({ frame_rate }) },
-                            { nmos::caps::format::frame_width, nmos::make_caps_integer_constraint({ frame_width }) },
-                            { nmos::caps::format::frame_height, nmos::make_caps_integer_constraint({ frame_height }) },
+                            { nmos::caps::format::grain_rate, nmos::make_caps_rational_constraint({ rx_frame_rate_parsed_rational }) },
+                            { nmos::caps::format::frame_width, nmos::make_caps_integer_constraint({ frame_w_r }) },
+                            { nmos::caps::format::frame_height, nmos::make_caps_integer_constraint({ frame_h_r }) },
                             { nmos::caps::format::interlace_mode, nmos::make_caps_string_constraint(interlace_modes) },
-                            { nmos::caps::format::color_sampling, nmos::make_caps_string_constraint({ sampling.name }) }
+                            { nmos::caps::format::color_sampling, nmos::make_caps_string_constraint({ "YCbCr-4:2:2" }) }
                         })
                     });
                 }
@@ -549,7 +660,7 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
                 {
                     // some of the parameter constraints recommended by BCP-006-01
                     // see https://specs.amwa.tv/bcp-006-01/branches/v1.0-dev/docs/NMOS_With_JPEG_XS.html#receivers
-                    const auto max_format_bit_rate = nmos::get_video_jxsv_bit_rate(frame_rate, frame_width, frame_height, max_bits_per_pixel);
+                    const auto max_format_bit_rate = nmos::get_video_jxsv_bit_rate(rx_frame_rate_parsed_rational, frame_w_r, frame_h_r, max_bits_per_pixel);
                     // round to nearest Megabit/second per examples in VSF TR-08:2022
                     const auto max_transport_bit_rate = uint64_t(transport_bit_rate_factor * max_format_bit_rate / 1e3 + 0.5) * 1000;
 
@@ -593,7 +704,7 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
                 // add an example constraint set; these should be completed fully!
                 receiver.data[nmos::fields::caps][nmos::fields::constraint_sets] = value_of({
                     value_of({
-                        { nmos::caps::format::grain_rate, nmos::make_caps_rational_constraint({ frame_rate }) }
+                        { nmos::caps::format::grain_rate, nmos::make_caps_rational_constraint({ rx_frame_rate_parsed_rational }) }
                     })
                 });
                 receiver.data[nmos::fields::version] = receiver.data[nmos::fields::caps][nmos::fields::version] = value(nmos::make_version());
@@ -604,7 +715,7 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
                 // add an example constraint set; these should be completed fully!
                 receiver.data[nmos::fields::caps][nmos::fields::constraint_sets] = value_of({
                     value_of({
-                        { nmos::caps::format::grain_rate, nmos::make_caps_rational_constraint({ frame_rate }) }
+                        { nmos::caps::format::grain_rate, nmos::make_caps_rational_constraint({ rx_frame_rate_parsed_rational }) }
                     })
                 });
                 receiver.data[nmos::fields::version] = receiver.data[nmos::fields::caps][nmos::fields::version] = value(nmos::make_version());
@@ -627,773 +738,10 @@ void node_implementation_init(nmos::node_model& model, nmos::experimental::contr
             if (!insert_resource_after(delay_millis, model.connection_resources, std::move(connection_receiver), gate)) throw node_implementation_init_exception();
         }
     }
-
-    // example event sources, flows and senders
-    for (int index = 0; 0 <= nmos::fields::events_port(model.settings) && index < how_many; ++index)
-    {
-        for (const auto& port : ws_sender_ports)
-        {
-            const auto source_id = impl::make_id(seed_id, nmos::types::source, port, index);
-            const auto flow_id = impl::make_id(seed_id, nmos::types::flow, port, index);
-            const auto sender_id = impl::make_id(seed_id, nmos::types::sender, port, index);
-
-            nmos::event_type event_type;
-            web::json::value events_type;
-            web::json::value events_state;
-            if (impl::ports::temperature == port)
-            {
-                event_type = impl::temperature_Celsius;
-
-                // see https://specs.amwa.tv/is-07/releases/v1.0.1/docs/3.0._Event_types.html#231-measurements
-                // and https://specs.amwa.tv/is-07/releases/v1.0.1/examples/eventsapi-type-number-measurement-get-200.html
-                // and https://specs.amwa.tv/is-07/releases/v1.0.1/examples/eventsapi-state-number-measurement-get-200.html
-                events_type = nmos::make_events_number_type({ -200, 10 }, { 1000, 10 }, { 1, 10 }, U("C"));
-                events_state = nmos::make_events_number_state({ source_id, flow_id }, { 201, 10 }, event_type);
-            }
-            else if (impl::ports::burn == port)
-            {
-                event_type = nmos::event_types::boolean;
-
-                // see https://specs.amwa.tv/is-07/releases/v1.0.1/docs/3.0._Event_types.html#21-boolean
-                events_type = nmos::make_events_boolean_type();
-                events_state = nmos::make_events_boolean_state({ source_id, flow_id }, false);
-            }
-            else if (impl::ports::nonsense == port)
-            {
-                event_type = nmos::event_types::string;
-
-                // see https://specs.amwa.tv/is-07/releases/v1.0.1/docs/3.0._Event_types.html#22-string
-                // and of course, https://en.wikipedia.org/wiki/Metasyntactic_variable
-                events_type = nmos::make_events_string_type(0, 0, U("^foo|bar|baz|qu+x$"));
-                events_state = nmos::make_events_string_state({ source_id, flow_id }, U("foo"));
-            }
-            else if (impl::ports::catcall == port)
-            {
-                event_type = impl::catcall;
-
-                // see https://specs.amwa.tv/is-07/releases/v1.0.1/docs/3.0._Event_types.html#3-enum
-                events_type = nmos::make_events_number_enum_type({
-                    { 1, { U("meow"), U("chatty") } },
-                    { 2, { U("purr"), U("happy") } },
-                    { 4, { U("hiss"), U("afraid") } },
-                    { 8, { U("yowl"), U("sonorous") } }
-                });
-                events_state = nmos::make_events_number_state({ source_id, flow_id }, 1, event_type);
-            }
-
-            // grain_rate is not set because these events are aperiodic
-            auto source = nmos::make_data_source(source_id, device_id, {}, event_type, model.settings);
-            impl::set_label_description(source, port, index);
-
-            auto events_source = nmos::make_events_source(source_id, events_state, events_type);
-
-            auto flow = nmos::make_json_data_flow(flow_id, source_id, device_id, event_type, model.settings);
-            impl::set_label_description(flow, port, index);
-
-            auto sender = nmos::make_sender(sender_id, flow_id, nmos::transports::websocket, device_id, {}, { host_interface.name }, model.settings);
-            impl::set_label_description(sender, port, index);
-            impl::insert_group_hint(sender, port, index);
-
-            // initialize this sender enabled, just to enable the IS-07-02 test suite to run immediately
-            auto connection_sender = nmos::make_connection_events_websocket_sender(sender_id, device_id, source_id, model.settings);
-            connection_sender.data[nmos::fields::endpoint_active][nmos::fields::master_enable] = connection_sender.data[nmos::fields::endpoint_staged][nmos::fields::master_enable] = value::boolean(true);
-            resolve_auto(sender, connection_sender, connection_sender.data[nmos::fields::endpoint_active][nmos::fields::transport_params]);
-            nmos::set_resource_subscription(sender, nmos::fields::master_enable(connection_sender.data[nmos::fields::endpoint_active]), {}, nmos::tai_now());
-
-            if (!insert_resource_after(delay_millis, model.node_resources, std::move(source), gate)) throw node_implementation_init_exception();
-            if (!insert_resource_after(delay_millis, model.node_resources, std::move(flow), gate)) throw node_implementation_init_exception();
-            if (!insert_resource_after(delay_millis, model.node_resources, std::move(sender), gate)) throw node_implementation_init_exception();
-            if (!insert_resource_after(delay_millis, model.connection_resources, std::move(connection_sender), gate)) throw node_implementation_init_exception();
-            if (!insert_resource_after(delay_millis, model.events_resources, std::move(events_source), gate)) throw node_implementation_init_exception();
-        }
-    }
-
-    // example event receivers
-    for (int index = 0; index < how_many; ++index)
-    {
-        for (const auto& port : ws_receiver_ports)
-        {
-            const auto receiver_id = impl::make_id(seed_id, nmos::types::receiver, port, index);
-
-            nmos::event_type event_type;
-            if (impl::ports::temperature == port)
-            {
-                // accept e.g. "number/temperature/F" or "number/temperature/K" as well as "number/temperature/C"
-                event_type = impl::temperature_wildcard;
-            }
-            else if (impl::ports::burn == port)
-            {
-                // accept any boolean
-                event_type = nmos::event_types::wildcard(nmos::event_types::boolean);
-            }
-            else if (impl::ports::nonsense == port)
-            {
-                // accept any string
-                event_type = nmos::event_types::wildcard(nmos::event_types::string);
-            }
-            else if (impl::ports::catcall == port)
-            {
-                // accept only a catcall
-                event_type = impl::catcall;
-            }
-
-            auto receiver = nmos::make_data_receiver(receiver_id, device_id, nmos::transports::websocket, { host_interface.name }, nmos::media_types::application_json, { event_type }, model.settings);
-            impl::set_label_description(receiver, port, index);
-            impl::insert_group_hint(receiver, port, index);
-
-            auto connection_receiver = nmos::make_connection_events_websocket_receiver(receiver_id, model.settings);
-            resolve_auto(receiver, connection_receiver, connection_receiver.data[nmos::fields::endpoint_active][nmos::fields::transport_params]);
-
-            if (!insert_resource_after(delay_millis, model.node_resources, std::move(receiver), gate)) throw node_implementation_init_exception();
-            if (!insert_resource_after(delay_millis, model.connection_resources, std::move(connection_receiver), gate)) throw node_implementation_init_exception();
-        }
-    }
-
-    // example channelmapping resources demonstrating a range of input/output capabilities
-    // see https://github.com/sony/nmos-cpp/issues/111#issuecomment-740613137
-
-    // example audio inputs
-    const bool channelmapping_receivers = 0 <= nmos::fields::channelmapping_port(model.settings) && rtp_receiver_ports.end() != boost::range::find(rtp_receiver_ports, impl::ports::audio);
-    for (int index = 0; channelmapping_receivers && index < how_many; ++index)
-    {
-        const auto stri = utility::conversions::details::to_string_t(index);
-
-        const auto id = U("input") + stri;
-
-        const auto name = U("IP Input ") + stri;
-        const auto description = U("SMPTE 2110-30 IP Input ") + stri;
-
-        const auto receiver_id = impl::make_id(seed_id, nmos::types::receiver, impl::ports::audio, index);
-        const auto parent = std::pair<nmos::id, nmos::type>(receiver_id, nmos::types::receiver);
-
-        const auto channel_labels = boost::copy_range<std::vector<utility::string_t>>(boost::irange(0, channel_count) | boost::adaptors::transformed([&](const int& index)
-        {
-            return impl::channels_repeat[index % (int)impl::channels_repeat.size()].label;
-        }));
-
-        // use default input capabilities to indicate no constraints
-        auto channelmapping_input = nmos::make_channelmapping_input(id, name, description, parent, channel_labels);
-        if (!insert_resource_after(delay_millis, model.channelmapping_resources, std::move(channelmapping_input), gate)) throw node_implementation_init_exception();
-    }
-
-    // example audio outputs
-    const bool channelmapping_senders = 0 <= nmos::fields::channelmapping_port(model.settings) && rtp_sender_ports.end() != boost::range::find(rtp_sender_ports, impl::ports::audio);
-    for (int index = 0; channelmapping_senders && index < how_many; ++index)
-    {
-        const auto stri = utility::conversions::details::to_string_t(index);
-
-        const auto id = U("output") + stri;
-
-        const auto name = U("IP Output ") + stri;
-        const auto description = U("SMPTE 2110-30 IP Output ") + stri;
-
-        const auto source_id = impl::make_id(seed_id, nmos::types::source, impl::ports::audio, index);
-
-        const auto channel_labels = boost::copy_range<std::vector<utility::string_t>>(boost::irange(0, channel_count) | boost::adaptors::transformed([&](const int& index)
-        {
-            return impl::channels_repeat[index % (int)impl::channels_repeat.size()].label;
-        }));
-
-        // omit routable inputs to indicate no restrictions
-        auto channelmapping_output = nmos::make_channelmapping_output(id, name, description, source_id, channel_labels);
-        if (!insert_resource_after(delay_millis, model.channelmapping_resources, std::move(channelmapping_output), gate)) throw node_implementation_init_exception();
-    }
-
-    const int input_block_size = 8;
-    const int input_block_count = 8;
-
-    // example non-IP audio input
-    if (0 <= nmos::fields::channelmapping_port(model.settings))
-    {
-        const auto id = U("inputA");
-
-        const auto name = U("MADI Input A");
-        const auto description = U("MADI Input A");
-
-        // non-IP audio inputs have no parent
-        const auto parent = std::pair<nmos::id, nmos::type>();
-
-        const auto channel_labels = boost::copy_range<std::vector<utility::string_t>>(boost::irange(0, input_block_size * input_block_count) | boost::adaptors::transformed([](const int& index)
-        {
-            return nmos::channel_symbols::Undefined(1 + index).name;
-        }));
-
-        // some example constraints; this input's channels can only be used in blocks and the channels cannot be reordered within each block
-        const auto reordering = false;
-        const auto block_size = input_block_size;
-
-        auto channelmapping_input = nmos::make_channelmapping_input(id, name, description, parent, channel_labels, reordering, block_size);
-        if (!insert_resource_after(delay_millis, model.channelmapping_resources, std::move(channelmapping_input), gate)) throw node_implementation_init_exception();
-    }
-
-    // example outputs to some audio gizmo
-    if (0 <= nmos::fields::channelmapping_port(model.settings))
-    {
-        const auto id = U("outputX");
-
-        const auto name = U("Gizmo Output X");
-        const auto description = U("Gizmo Output X");
-
-        const auto source_id = impl::make_id(seed_id, nmos::types::source, impl::ports::audio, how_many);
-
-        const auto channel_labels = boost::copy_range<std::vector<utility::string_t>>(boost::irange(0, input_block_size) | boost::adaptors::transformed([](const int& index)
-        {
-            return nmos::channel_symbols::Undefined(1 + index).name;
-        }));
-
-        // some example constraints; only allow inputs from the example non-IP audio input
-        auto routable_inputs = std::vector<nmos::channelmapping_id>{ U("inputA") };
-        // do not allow unrouted channels
-
-        // start with a valid active map
-        auto active_map = boost::copy_range<std::vector<std::pair<nmos::channelmapping_id, uint32_t>>>(boost::irange(0, input_block_size) | boost::adaptors::transformed([](const int& index)
-        {
-            return std::pair<nmos::channelmapping_id, uint32_t>{ U("inputA"), index };
-        }));
-
-        auto channelmapping_output = nmos::make_channelmapping_output(id, name, description, source_id, channel_labels, routable_inputs, active_map);
-        if (!insert_resource_after(delay_millis, model.channelmapping_resources, std::move(channelmapping_output), gate)) throw node_implementation_init_exception();
-    }
-
-    // example source for some audio gizmo
-    if (0 <= nmos::fields::channelmapping_port(model.settings))
-    {
-        const auto source_id = impl::make_id(seed_id, nmos::types::source, impl::ports::audio, how_many);
-
-        const auto channels = boost::copy_range<std::vector<nmos::channel>>(boost::irange(0, input_block_size) | boost::adaptors::transformed([](const int& index)
-        {
-            return nmos::channel{ {}, nmos::channel_symbols::Undefined(1 + index) };
-        }));
-
-        auto source = nmos::make_audio_source(source_id, device_id, nmos::clock_names::clk0, frame_rate, channels, model.settings);
-        impl::set_label_description(source, impl::ports::audio, how_many);
-
-        if (!insert_resource_after(delay_millis, model.node_resources, std::move(source), gate)) throw node_implementation_init_exception();
-    }
-
-    // example inputs from some audio gizmo
-    if (0 <= nmos::fields::channelmapping_port(model.settings))
-    {
-        const auto id = U("inputX");
-
-        const auto name = U("Gizmo Input X");
-        const auto description = U("Gizmo Input X");
-
-        // the audio gizmo is re-entrant
-        const auto source_id = impl::make_id(seed_id, nmos::types::source, impl::ports::audio, how_many);
-        const auto parent = std::pair<nmos::id, nmos::type>(source_id, nmos::types::source);
-
-        const auto channel_labels = boost::copy_range<std::vector<utility::string_t>>(boost::irange(0, input_block_size) | boost::adaptors::transformed([](const int& index)
-        {
-            return nmos::channel_symbols::Undefined(1 + index).name;
-        }));
-
-        // this input is weird, it is block-based but allows reordering of channels within a block
-        const auto reordering = true;
-        const auto block_size = 2;
-
-        auto channelmapping_input = nmos::make_channelmapping_input(id, name, description, parent, channel_labels, reordering, block_size);
-        if (!insert_resource_after(delay_millis, model.channelmapping_resources, std::move(channelmapping_input), gate)) throw node_implementation_init_exception();
-    }
-
-    // example non-ST 2110-30 audio output
-    if (0 <= nmos::fields::channelmapping_port(model.settings))
-    {
-        const auto id = U("outputB");
-
-        const auto name = U("AES Output B");
-        const auto description = U("AES Output B");
-
-        // non-IP audio outputs have no sourceid
-        const auto source_id = nmos::id();
-
-        const auto channel_labels = boost::copy_range<std::vector<utility::string_t>>(nmos::channel_symbols::ST | boost::adaptors::transformed([](const nmos::channel_symbol& symbol)
-        {
-            return symbol.name;
-        }));
-
-        // allow inputs from the audio gizmo
-        auto routable_inputs = std::vector<nmos::channelmapping_id>{ U("inputX") };
-        // allow unrouted channels
-        routable_inputs.push_back({});
-
-        auto channelmapping_output = nmos::make_channelmapping_output(id, name, description, source_id, channel_labels, routable_inputs);
-        if (!insert_resource_after(delay_millis, model.channelmapping_resources, std::move(channelmapping_output), gate)) throw node_implementation_init_exception();
-    }
-
-    // examples of using IS-12 control protocol
-    // they are based on the NC-DEVICE-MOCK
-    // See https://specs.amwa.tv/nmos-device-control-mock/#about-nc-device-mock
-    // See https://github.com/AMWA-TV/nmos-device-control-mock/blob/main/code/src/NCModel/Features.ts
-    if (0 <= nmos::fields::control_protocol_ws_port(model.settings))
-    {
-        // example to create a non-standard Gain control class
-        const auto gain_control_class_id = nmos::make_nc_class_id(nmos::nc_worker_class_id, 0, { 1 });
-        const web::json::field_as_number gain_value{ U("gainValue") };
-        {
-            // Gain control class property descriptors
-            std::vector<web::json::value> gain_control_property_descriptors = { nmos::experimental::make_control_class_property_descriptor(U("Gain value"), { 3, 1 }, gain_value, U("NcFloat32")) };
-
-            // create Gain control class descriptor
-            auto gain_control_class_descriptor = nmos::experimental::make_control_class_descriptor(U("Gain control class descriptor"), gain_control_class_id, U("GainControl"), gain_control_property_descriptors);
-
-            // insert Gain control class descriptor to global state, which will be used by the control_protocol_ws_message_handler to process incoming ws message
-            control_protocol_state.insert(gain_control_class_descriptor);
-        }
-        // helper function to create Gain control instance
-        auto make_gain_control = [&gain_value, &gain_control_class_id](nmos::nc_oid oid, nmos::nc_oid owner, const utility::string_t& role, const utility::string_t& user_label, const utility::string_t& description, const web::json::value& touchpoints, const web::json::value& runtime_property_constraints, float gain)
-        {
-            auto data = nmos::details::make_nc_worker(gain_control_class_id, oid, true, owner, role, value::string(user_label), description, touchpoints, runtime_property_constraints, true);
-            data[gain_value] = value::number(gain);
-
-            return nmos::control_protocol_resource{ nmos::is12_versions::v1_0, nmos::types::nc_worker, std::move(data), true };
-        };
-
-        // example to create a non-standard Example control class
-        const auto example_control_class_id = nmos::make_nc_class_id(nmos::nc_worker_class_id, 0, { 2 });
-        const web::json::field_as_number enum_property{ U("enumProperty") };
-        const web::json::field_as_string string_property{ U("stringProperty") };
-        const web::json::field_as_number number_property{ U("numberProperty") };
-        const web::json::field_as_number deprecated_number_property{ U("deprecatedNumberProperty") };
-        const web::json::field_as_bool boolean_property{ U("booleanProperty") };
-        const web::json::field_as_value object_property{ U("objectProperty") };
-        const web::json::field_as_number method_no_args_count{ U("methodNoArgsCount") };
-        const web::json::field_as_number method_simple_args_count{ U("methodSimpleArgsCount") };
-        const web::json::field_as_number method_object_arg_count{ U("methodObjectArgCount") };
-        const web::json::field_as_array string_sequence{ U("stringSequence") };
-        const web::json::field_as_array boolean_sequence{ U("booleanSequence") };
-        const web::json::field_as_array enum_sequence{ U("enumSequence") };
-        const web::json::field_as_array number_sequence{ U("numberSequence") };
-        const web::json::field_as_array object_sequence{ U("objectSequence") };
-        const web::json::field_as_number enum_arg{ U("enumArg") };
-        const web::json::field_as_string string_arg{ U("stringArg") };
-        const web::json::field_as_number number_arg{ U("numberArg") };
-        const web::json::field_as_bool boolean_arg{ U("booleanArg") };
-        const web::json::field_as_value obj_arg{ U("objArg") };
-        enum example_enum
-        {
-            Undefined = 0,
-            Alpha = 1,
-            Beta = 2,
-            Gamma = 3
-        };
-        {
-            // following constraints are used for the example control class level 0 datatype, level 1 property constraints and the method parameters constraints
-            auto make_string_example_argument_constraints = []() {return nmos::details::make_nc_parameter_constraints_string(10, U("^[a-z]+$")); };
-            auto make_number_example_argument_constraints = []() {return nmos::details::make_nc_parameter_constraints_number(0, 1000, 1); };
-
-            // Example control class property descriptors
-            std::vector<web::json::value> example_control_property_descriptors = {
-                nmos::experimental::make_control_class_property_descriptor(U("Example enum property"), { 3, 1 }, enum_property, U("ExampleEnum")),
-                // create "Example string property" with level 1: property constraints, See https://specs.amwa.tv/ms-05-02/branches/v1.0.x/docs/Constraints.html
-                // use nmos::details::make_nc_parameter_constraints_string to create property constraints
-                nmos::experimental::make_control_class_property_descriptor(U("Example string property"), { 3, 2 }, string_property, U("NcString"), false, false, false, false, make_string_example_argument_constraints()),
-                // create "Example numeric property" with level 1: property constraints, See https://specs.amwa.tv/ms-05-02/branches/v1.0.x/docs/Constraints.html
-                // use nmos::details::make_nc_parameter_constraints_number to create property constraints
-                nmos::experimental::make_control_class_property_descriptor(U("Example numeric property"), { 3, 3 }, number_property, U("NcUint64"), false, false, false, false, make_number_example_argument_constraints()),
-                nmos::experimental::make_control_class_property_descriptor(U("Example deprecated numeric property"), { 3, 4 }, deprecated_number_property, U("NcUint64"), false, false, false, true, make_number_example_argument_constraints()),
-                nmos::experimental::make_control_class_property_descriptor(U("Example boolean property"), { 3, 5 }, boolean_property, U("NcBoolean")),
-                nmos::experimental::make_control_class_property_descriptor(U("Example object property"), { 3, 6 }, object_property, U("ExampleDataType")),
-                nmos::experimental::make_control_class_property_descriptor(U("Example method no args invoke counter"), { 3, 7 }, method_no_args_count, U("NcUint64"), true),
-                nmos::experimental::make_control_class_property_descriptor(U("Example method simple args invoke counter"), { 3, 8 }, method_simple_args_count, U("NcUint64"), true),
-                nmos::experimental::make_control_class_property_descriptor(U("Example method obj arg invoke counter"), { 3, 9 }, method_object_arg_count, U("NcUint64"), true),
-                // create "Example sequence string property" with level 1: property constraints, See https://specs.amwa.tv/ms-05-02/branches/v1.0.x/docs/Constraints.html
-                // use nmos::details::make_nc_parameter_constraints_string to create sequence property constraints
-                nmos::experimental::make_control_class_property_descriptor(U("Example string sequence property"), { 3, 10 }, string_sequence, U("NcString"), false, false, true, false, make_string_example_argument_constraints()),
-                nmos::experimental::make_control_class_property_descriptor(U("Example boolean sequence property"), { 3, 11 }, boolean_sequence, U("NcBoolean"), false, false, true),
-                nmos::experimental::make_control_class_property_descriptor(U("Example enum sequence property"), { 3, 12 }, enum_sequence, U("ExampleEnum"), false, false, true),
-                // create "Example sequence numeric property" with level 1: property constraints, See https://specs.amwa.tv/ms-05-02/branches/v1.0.x/docs/Constraints.html
-                // use nmos::details::make_nc_parameter_constraints_number to create sequence property constraints
-                nmos::experimental::make_control_class_property_descriptor(U("Example number sequence property"), { 3, 13 }, number_sequence, U("NcUint64"), false, false, true, false, make_number_example_argument_constraints()),
-                nmos::experimental::make_control_class_property_descriptor(U("Example object sequence property"), { 3, 14 }, object_sequence, U("ExampleDataType"), false, false, true)
-            };
-
-            auto example_method_with_no_args = [](nmos::resources& resources, const nmos::resource& resource, const web::json::value& arguments, bool is_deprecated, slog::base_gate& gate)
-            {
-                // note, model mutex is already locked by the outer function, so access to control_protocol_resources is OK...
-
-                slog::log<slog::severities::more_info>(gate, SLOG_FLF) << "Executing the example method with no arguments";
-
-                return nmos::details::make_nc_method_result({ is_deprecated ? nmos::nc_method_status::method_deprecated : nmos::nc_method_status::ok });
-            };
-            auto example_method_with_simple_args = [](nmos::resources& resources, const nmos::resource& resource, const web::json::value& arguments, bool is_deprecated, slog::base_gate& gate)
-            {
-                // note, model mutex is already locked by the outer function, so access to control_protocol_resources is OK...
-                // and the method parameters constriants has already been validated by the outer function
-
-                slog::log<slog::severities::more_info>(gate, SLOG_FLF) << "Executing the example method with simple arguments: " << arguments.serialize();
-
-                return nmos::details::make_nc_method_result({ is_deprecated ? nmos::nc_method_status::method_deprecated : nmos::nc_method_status::ok });
-            };
-            auto example_method_with_object_args = [](nmos::resources& resources, const nmos::resource& resource, const web::json::value& arguments, bool is_deprecated, slog::base_gate& gate)
-            {
-                // note, model mutex is already locked by the outer function, so access to control_protocol_resources is OK...
-                // and the method parameters constriants has already been validated by the outer function
-
-                slog::log<slog::severities::more_info>(gate, SLOG_FLF) << "Executing the example method with object argument: " << arguments.serialize();
-
-                return nmos::details::make_nc_method_result({ is_deprecated ? nmos::nc_method_status::method_deprecated : nmos::nc_method_status::ok });
-            };
-            // Example control class method descriptors
-            std::vector<nmos::experimental::method> example_control_method_descriptors =
-            {
-                { nmos::experimental::make_control_class_method_descriptor(U("Example method with no arguments"), { 3, 1 }, U("MethodNoArgs"), U("NcMethodResult"), {}, false, example_method_with_no_args) },
-                { nmos::experimental::make_control_class_method_descriptor(U("Example deprecated method with no arguments"), { 3, 2 }, U("MethodNoArgs"), U("NcMethodResult"), {}, true, example_method_with_no_args) },
-                { nmos::experimental::make_control_class_method_descriptor(U("Example method with simple arguments"), { 3, 3 }, U("MethodSimpleArgs"), U("NcMethodResult"),
-                     {
-                        nmos::experimental::make_control_class_method_parameter_descriptor(U("Enum example argument"), enum_arg, U("ExampleEnum")),
-                        nmos::experimental::make_control_class_method_parameter_descriptor(U("String example argument"), string_arg, U("NcString"), false, false, make_string_example_argument_constraints()), // e.g. include method property constraints
-                        nmos::experimental::make_control_class_method_parameter_descriptor(U("Number example argument"), number_arg, U("NcUint64"), false, false, make_number_example_argument_constraints()), // e.g. include method property constraints
-                        nmos::experimental::make_control_class_method_parameter_descriptor(U("Boolean example argument"), boolean_arg, U("NcBoolean"))
-                    },
-                    false, example_method_with_simple_args)
-                },
-                { nmos::experimental::make_control_class_method_descriptor(U("Example method with object argument"), { 3, 4 }, U("MethodObjectArg"), U("NcMethodResult"),
-                    {
-                        nmos::experimental::make_control_class_method_parameter_descriptor(U("Object example argument"), obj_arg, U("ExampleDataType"))
-                    },
-                    false, example_method_with_object_args)
-                }
-            };
-
-            // create Example control class descriptor
-            auto example_control_class_descriptor = nmos::experimental::make_control_class_descriptor(U("Example control class descriptor"), example_control_class_id, U("ExampleControl"), example_control_property_descriptors, example_control_method_descriptors);
-
-            // insert Example control class descriptor to global state, which will be used by the control_protocol_ws_message_handler to process incoming ws message
-            control_protocol_state.insert(example_control_class_descriptor);
-
-            // create/insert Example datatypes to global state, which will be used by the control_protocol_ws_message_handler to process incoming ws message
-            auto make_example_enum_datatype = [&]()
-            {
-                using web::json::value;
-
-                auto items = value::array();
-                web::json::push_back(items, nmos::details::make_nc_enum_item_descriptor(U("Undefined"), U("Undefined"), example_enum::Undefined));
-                web::json::push_back(items, nmos::details::make_nc_enum_item_descriptor(U("Alpha"), U("Alpha"), example_enum::Alpha));
-                web::json::push_back(items, nmos::details::make_nc_enum_item_descriptor(U("Beta"), U("Beta"), example_enum::Beta));
-                web::json::push_back(items, nmos::details::make_nc_enum_item_descriptor(U("Gamma"), U("Gamma"), example_enum::Gamma));
-                return nmos::details::make_nc_datatype_descriptor_enum(U("Example enum datatype"), U("ExampleEnum"), items, value::null());
-            };
-            auto make_example_datatype_datatype = [&]()
-            {
-                using web::json::value;
-
-                auto fields = value::array();
-                web::json::push_back(fields, nmos::details::make_nc_field_descriptor(U("Enum property example"), enum_property, U("ExampleEnum"), false, false, value::null()));
-                {
-                    // level 0: datatype constraints, See https://specs.amwa.tv/ms-05-02/branches/v1.0.x/docs/Constraints.html
-                    // use nmos::details::make_nc_parameter_constraints_string to create datatype constraints
-                    value datatype_constraints = make_string_example_argument_constraints();
-                    web::json::push_back(fields, nmos::details::make_nc_field_descriptor(U("String property example"), string_property, U("NcString"), false, false, datatype_constraints));
-                }
-                {
-                    // level 0: datatype constraints, See https://specs.amwa.tv/ms-05-02/branches/v1.0.x/docs/Constraints.html
-                    // use nmos::details::make_nc_parameter_constraints_number to create datatype constraints
-                    value datatype_constraints = make_number_example_argument_constraints();
-                    web::json::push_back(fields, nmos::details::make_nc_field_descriptor(U("Number property example"), number_property, U("NcUint64"), false, false, datatype_constraints));
-                }
-                web::json::push_back(fields, nmos::details::make_nc_field_descriptor(U("Boolean property example"), boolean_property, U("NcBoolean"), false, false, value::null()));
-                return nmos::details::make_nc_datatype_descriptor_struct(U("Example data type"), U("ExampleDataType"), fields, value::null());
-            };
-            control_protocol_state.insert(nmos::experimental::datatype_descriptor{ make_example_enum_datatype() });
-            control_protocol_state.insert(nmos::experimental::datatype_descriptor{ make_example_datatype_datatype() });
-        }
-        // helper function to create Example datatype
-        auto make_example_datatype = [&](example_enum enum_property_, const utility::string_t& string_property_, uint64_t number_property_, bool boolean_property_)
-        {
-            using web::json::value_of;
-
-            return value_of({
-                { enum_property, enum_property_ },
-                { string_property, string_property_ },
-                { number_property, number_property_ },
-                { boolean_property, boolean_property_ }
-            });
-        };
-        // helper function to create Example control instance
-        auto make_example_control = [&](nmos::nc_oid oid, nmos::nc_oid owner, const utility::string_t& role, const utility::string_t& user_label, const utility::string_t& description, const value& touchpoints,
-            const value& runtime_property_constraints,  // level 2: runtime constraints. See https://specs.amwa.tv/ms-05-02/branches/v1.0.x/docs/Constraints.html
-                                                        // use of make_nc_property_constraints_string and make_nc_property_constraints_number to create runtime constraints
-            example_enum enum_property_,
-            const utility::string_t& string_property_,
-            uint64_t number_property_,
-            uint64_t deprecated_number_property_,
-            bool boolean_property_,
-            const value& object_property_,
-            uint64_t method_no_args_count_,
-            uint64_t method_simple_args_count_,
-            uint64_t method_object_arg_count_,
-            std::vector<utility::string_t> string_sequence_,
-            std::vector<bool> boolean_sequence_,
-            std::vector<example_enum> enum_sequence_,
-            std::vector<uint64_t> number_sequence_,
-            std::vector<value> object_sequence_)
-        {
-            auto data = nmos::details::make_nc_worker(example_control_class_id, oid, true, owner, role, value::string(user_label), description, touchpoints, runtime_property_constraints, true);
-            data[enum_property] = value::number(enum_property_);
-            data[string_property] = value::string(string_property_);
-            data[number_property] = value::number(number_property_);
-            data[deprecated_number_property] = value::number(deprecated_number_property_);
-            data[boolean_property] = value::boolean(boolean_property_);
-            data[object_property] = object_property_;
-            data[method_no_args_count] = value::number(method_no_args_count_);
-            data[method_simple_args_count] = value::number(method_simple_args_count_);
-            data[method_object_arg_count] = value::number(method_object_arg_count_);
-            {
-                value sequence;
-                for (const auto& value_ : string_sequence_) { web::json::push_back(sequence, value::string(value_)); }
-                data[string_sequence] = sequence;
-            }
-            {
-                value sequence;
-                for (const auto& value_ : boolean_sequence_) { web::json::push_back(sequence, value::boolean(value_)); }
-                data[boolean_sequence] = sequence;
-            }
-            {
-                value sequence;
-                for (const auto& value_ : enum_sequence_) { web::json::push_back(sequence, value_); }
-                data[enum_sequence] = sequence;
-            }
-            {
-                value sequence;
-                for (const auto& value_ : number_sequence_) { web::json::push_back(sequence, value_); }
-                data[number_sequence] = sequence;
-            }
-            {
-                value sequence;
-                for (const auto& value_ : object_sequence_) { web::json::push_back(sequence, value_); }
-                data[object_sequence] = sequence;
-            }
-
-            return nmos::control_protocol_resource{ nmos::is12_versions::v1_0, nmos::types::nc_worker, std::move(data), true };
-        };
-
-        // example to create a non-standard Temperature Sensor control class
-        const auto temperature_sensor_control_class_id = nmos::make_nc_class_id(nmos::nc_worker_class_id, 0, { 3 });
-        const web::json::field_as_number temperature{ U("temperature") };
-        const web::json::field_as_string unit{ U("uint") };
-        {
-            // Temperature Sensor control class property descriptors
-            std::vector<web::json::value> temperature_sensor_property_descriptors = {
-                nmos::experimental::make_control_class_property_descriptor(U("Temperature"), { 3, 1 }, temperature, U("NcFloat32"), true),
-                nmos::experimental::make_control_class_property_descriptor(U("Unit"), { 3, 2 }, unit, U("NcString"), true)
-            };
-
-            // create Temperature Sensor control class descriptor
-            auto temperature_sensor_control_class_descriptor = nmos::experimental::make_control_class_descriptor(U("Temperature Sensor control class descriptor"), temperature_sensor_control_class_id, U("TemperatureSensor"), temperature_sensor_property_descriptors);
-
-            // insert Temperature Sensor control class descriptor to global state, which will be used by the control_protocol_ws_message_handler to process incoming ws message
-            control_protocol_state.insert(temperature_sensor_control_class_descriptor);
-        }
-        // helper function to create Temperature Sensor control instance
-        auto make_temperature_sensor = [&temperature, &unit, temperature_sensor_control_class_id](nmos::nc_oid oid, nmos::nc_oid owner, const utility::string_t& role, const utility::string_t& user_label, const utility::string_t& description, const web::json::value& touchpoints, const web::json::value& runtime_property_constraints, float temperature_, const utility::string_t& unit_)
-        {
-            auto data = nmos::details::make_nc_worker(temperature_sensor_control_class_id, oid, true, owner, role, value::string(user_label), description, touchpoints, runtime_property_constraints, true);
-            data[temperature] = value::number(temperature_);
-            data[unit] = value::string(unit_);
-
-            return nmos::control_protocol_resource{ nmos::is12_versions::v1_0, nmos::types::nc_worker, std::move(data), true };
-        };
-
-        // example root block
-        auto root_block = nmos::make_root_block();
-
-        nmos::nc_oid oid = nmos::root_block_oid;
-
-        // example device manager
-        auto device_manager = nmos::make_device_manager(++oid, model.settings);
-
-        // example class manager
-        auto class_manager = nmos::make_class_manager(++oid, control_protocol_state);
-
-        // example stereo gain
-        const auto stereo_gain_oid = ++oid;
-        auto stereo_gain = nmos::make_block(stereo_gain_oid, nmos::root_block_oid, U("stereo-gain"), U("Stereo gain"), U("Stereo gain block"));
-
-        // example channel gain
-        const auto channel_gain_oid = ++oid;
-        auto channel_gain = nmos::make_block(channel_gain_oid, stereo_gain_oid, U("channel-gain"), U("Channel gain"), U("Channel gain block"));
-        // example left/right gains
-        auto left_gain = make_gain_control(++oid, channel_gain_oid, U("left-gain"), U("Left gain"), U("Left channel gain"), value::null(), value::null(), 0.0);
-        auto right_gain = make_gain_control(++oid, channel_gain_oid, U("right-gain"), U("Right gain"), U("Right channel gain"), value::null(), value::null(), 0.0);
-        // add left-gain and right-gain to channel gain
-        nmos::push_back(channel_gain, left_gain);
-        nmos::push_back(channel_gain, right_gain);
-
-        // example master-gain
-        auto master_gain = make_gain_control(++oid, channel_gain_oid, U("master-gain"), U("Master gain"), U("Master gain block"), value::null(), value::null(), 0.0);
-        // add channel-gain and master-gain to stereo-gain
-        nmos::push_back(stereo_gain, channel_gain);
-        nmos::push_back(stereo_gain, master_gain);
-
-        // example example-control
-        auto example_control = make_example_control(++oid, nmos::root_block_oid, U("ExampleControl"), U("Example control worker"), U("Example control worker"),
-            value::null(),
-            // specify the level 2: runtime constraints, see https://specs.amwa.tv/ms-05-02/branches/v1.0.x/docs/Constraints.html
-            // use of make_nc_property_constraints_string and make_nc_property_constraints_number to create runtime constraints
-            value_of({
-                { nmos::details::make_nc_property_constraints_string({3, 2}, 5, U("^[a-z]+$")) },
-                { nmos::details::make_nc_property_constraints_number({3, 3}, 10, 100, 2) }
-            }),
-            example_enum::Undefined,
-            U("test"),
-            30,
-            10,
-            false,
-            make_example_datatype(example_enum::Undefined, U("default"), 5, false),
-            0,
-            0,
-            0,
-            { U("red"), U("blue"), U("green") },
-            { true, false },
-            { example_enum::Alpha, example_enum::Gamma },
-            { 0, 50, 80 },
-            { make_example_datatype(example_enum::Alpha, U("example"), 50, false), make_example_datatype(example_enum::Gamma, U("different"), 75, true) }
-        );
-
-        // example receiver-monitor(s)
-        {
-            int count = 0;
-            for (int index = 0; index < how_many; ++index)
-            {
-                for (const auto& port : rtp_receiver_ports)
-                {
-                    const auto receiver_id = impl::make_id(seed_id, nmos::types::receiver, port, index);
-
-                    utility::stringstream_t role;
-                    role << U("monitor-") << ++count;
-                    const auto& receiver = nmos::find_resource(model.node_resources, receiver_id);
-                    const auto receiver_monitor = nmos::make_receiver_monitor(++oid, true, nmos::root_block_oid, role.str(), nmos::fields::label(receiver->data), nmos::fields::description(receiver->data), value_of({ { nmos::details::make_nc_touchpoint_nmos({nmos::ncp_nmos_resource_types::receiver, receiver_id}) } }));
-
-                    // add receiver-monitor to root-block
-                    nmos::push_back(root_block, receiver_monitor);
-                }
-            }
-        }
-
-        // example temperature-sensor
-        const auto temperature_sensor = make_temperature_sensor(++oid, nmos::root_block_oid, U("temperature-sensor"), U("Temperature Sensor"), U("Temperature Sensor block"), value::null(), value::null(), 0.0, U("Celsius"));
-
-        // add temperature-sensor to root-block
-        nmos::push_back(root_block, temperature_sensor);
-        // add example-control to root-block
-        nmos::push_back(root_block, example_control);
-        // add stereo-gain to root-block
-        nmos::push_back(root_block, stereo_gain);
-        // add class-manager to root-block
-        nmos::push_back(root_block, class_manager);
-        // add device-manager to root-block
-        nmos::push_back(root_block, device_manager);
-
-        // insert control protocol resources to model
-        insert_root_after(delay_millis, root_block, gate);
-    }
 }
 
 void node_implementation_run(nmos::node_model& model, slog::base_gate& gate)
 {
-    auto lock = model.read_lock();
-
-    const auto seed_id = nmos::experimental::fields::seed_id(model.settings);
-    const auto how_many = impl::fields::how_many(model.settings);
-    const auto sender_ports = impl::parse_ports(impl::fields::senders(model.settings));
-    const auto ws_sender_ports = boost::copy_range<std::vector<impl::port>>(sender_ports | boost::adaptors::filtered(impl::is_ws_port));
-
-    // start background tasks to intermittently update the state of the event sources, to cause events to be emitted to connected receivers
-
-    nmos::details::seed_generator events_seeder;
-    std::shared_ptr<std::default_random_engine> events_engine(new std::default_random_engine(events_seeder));
-
-    auto cancellation_source = pplx::cancellation_token_source();
-
-    auto token = cancellation_source.get_token();
-    auto events = pplx::do_while([&model, seed_id, how_many, ws_sender_ports, events_engine, &gate, token]
-    {
-        const auto event_interval = std::uniform_real_distribution<>(0.5, 5.0)(*events_engine);
-        return pplx::complete_after(std::chrono::milliseconds(std::chrono::milliseconds::rep(1000 * event_interval)), token).then([&model, seed_id, how_many, ws_sender_ports, events_engine, &gate]
-        {
-            auto lock = model.write_lock();
-
-            // make example temperature data ... \/\/\/\/ ... around 200
-            const nmos::events_number temp(175.0 + std::abs(nmos::tai_now().seconds % 100 - 50), 10);
-            // i.e. 17.5-22.5 C
-
-            for (int index = 0; 0 <= nmos::fields::events_port(model.settings) && index < how_many; ++index)
-            {
-                for (const auto& port : ws_sender_ports)
-                {
-                    const auto source_id = impl::make_id(seed_id, nmos::types::source, port, index);
-                    const auto flow_id = impl::make_id(seed_id, nmos::types::flow, port, index);
-
-                    modify_resource(model.events_resources, source_id, [&](nmos::resource& resource)
-                    {
-                        if (impl::ports::temperature == port)
-                        {
-                            nmos::fields::endpoint_state(resource.data) = nmos::make_events_number_state({ source_id, flow_id }, temp, impl::temperature_Celsius);
-                        }
-                        else if (impl::ports::burn == port)
-                        {
-                            nmos::fields::endpoint_state(resource.data) = nmos::make_events_boolean_state({ source_id, flow_id }, temp.scaled_value() > 20.0);
-                        }
-                        else if (impl::ports::nonsense == port)
-                        {
-                            const auto nonsenses = { U("foo"), U("bar"), U("baz"), U("qux"), U("quux"), U("quuux") };
-                            const auto& nonsense = *(nonsenses.begin() + (std::min)(std::geometric_distribution<size_t>()(*events_engine), nonsenses.size() - 1));
-                            nmos::fields::endpoint_state(resource.data) = nmos::make_events_string_state({ source_id, flow_id }, nonsense);
-                        }
-                        else if (impl::ports::catcall == port)
-                        {
-                            const auto catcalls = { 1, 2, 4, 8 };
-                            const auto& catcall = *(catcalls.begin() + (std::min)(std::geometric_distribution<size_t>()(*events_engine), catcalls.size() - 1));
-                            nmos::fields::endpoint_state(resource.data) = nmos::make_events_number_state({ source_id, flow_id }, catcall, impl::catcall);
-                        }
-                    });
-                }
-            }
-
-            // update temperature sensor
-            {
-                const auto temperature_sensor_control_class_id = nmos::make_nc_class_id(nmos::nc_worker_class_id, 0, { 3 });
-                const web::json::field_as_number temperature{ U("temperature") };
-
-                auto& resources = model.control_protocol_resources;
-
-                auto found = nmos::find_resource_if(resources, nmos::types::nc_worker, [&temperature_sensor_control_class_id](const nmos::resource& resource)
-                {
-                    return temperature_sensor_control_class_id == nmos::details::parse_nc_class_id(nmos::fields::nc::class_id(resource.data));
-                });
-
-                if (resources.end() != found)
-                {
-                    const auto property_changed_event = nmos::make_property_changed_event(nmos::fields::nc::oid(found->data),
-                    {
-                        { {3, 1}, nmos::nc_property_change_type::type::value_changed, web::json::value(temp.scaled_value()) }
-                    });
-
-                    nmos::modify_control_protocol_resource(model.control_protocol_resources, found->id, [&](nmos::resource& resource)
-                    {
-                        resource.data[temperature] = temp.scaled_value();
-
-                    }, property_changed_event);
-                }
-            }
-
-            slog::log<slog::severities::more_info>(gate, SLOG_FLF) << "Temperature updated: " << temp.scaled_value() << " (" << impl::temperature_Celsius.name << ")";
-
-            model.notify();
-
-            return true;
-        });
-    }, token);
-
-    // wait for the thread to be interrupted because the server is being shut down
-    model.shutdown_condition.wait(lock, [&] { return model.shutdown; });
-
-    cancellation_source.cancel();
-    // wait without the lock since it is also used by the background tasks
-    nmos::details::reverse_lock_guard<nmos::read_lock> unlock{ lock };
-
-    events.wait();
 }
 
 // Example System API node behaviour callback to perform application-specific operations when the global configuration resource changes
@@ -1438,14 +786,14 @@ nmos::registration_handler make_node_implementation_registration_handler(slog::b
 }
 
 // Example Connection API callback to parse "transport_file" during a PATCH /staged request
-nmos::transport_file_parser make_node_implementation_transport_file_parser()
+nmos::transport_file_parser make_node_implementation_transport_file_parser(slog::base_gate& gate)
 {
     // this example uses a custom transport file parser to handle video/jxsv in addition to the core media types
     // otherwise, it could simply return &nmos::parse_rtp_transport_file
     // (if this callback is specified, an 'empty' std::function is not allowed)
     return [](const nmos::resource& receiver, const nmos::resource& connection_receiver, const utility::string_t& transport_file_type, const utility::string_t& transport_file_data, slog::base_gate& gate)
     {
-        const auto validate_sdp_parameters = [](const web::json::value& receiver, const nmos::sdp_parameters& sdp_params)
+        const auto validate_sdp_parameters = [&gate](const web::json::value& receiver, const nmos::sdp_parameters& sdp_params)
         {
             if (nmos::media_types::video_jxsv == nmos::get_media_type(sdp_params))
             {
@@ -1462,7 +810,7 @@ nmos::transport_file_parser make_node_implementation_transport_file_parser()
 }
 
 // Example Connection API callback to perform application-specific validation of the merged /staged endpoint during a PATCH /staged request
-nmos::details::connection_resource_patch_validator make_node_implementation_patch_validator()
+nmos::details::connection_resource_patch_validator make_node_implementation_patch_validator(slog::base_gate& gate)
 {
     // this example uses an 'empty' std::function because it does not need to do any validation
     // beyond what is expressed by the schemas and /constraints endpoint
@@ -1470,26 +818,28 @@ nmos::details::connection_resource_patch_validator make_node_implementation_patc
 }
 
 // Example Connection API activation callback to resolve "auto" values when /staged is transitioned to /active
-nmos::connection_resource_auto_resolver make_node_implementation_auto_resolver(const nmos::settings& settings)
+nmos::connection_resource_auto_resolver make_node_implementation_auto_resolver(const nmos::settings& settings, slog::base_gate& gate)
 {
     using web::json::value;
 
     const auto seed_id = nmos::experimental::fields::seed_id(settings);
     const auto device_id = impl::make_id(seed_id, nmos::types::device);
-    const auto how_many = impl::fields::how_many(settings);
+    const auto senders_count = impl::parse_count(impl::fields::senders_count(settings)); // max count of elements = 4 (because 4 types of ports: video, audio, mux, data)
+    const auto senders_count_total = std::accumulate(senders_count.begin(), senders_count.end(), 0);
+    const auto receivers_count = impl::parse_count(impl::fields::receivers_count(settings)); // max count of elements = 4 (because 4 types of ports: video, audio, mux, data)
+    const auto receivers_count_total = std::accumulate(receivers_count.begin(), receivers_count.end(), 0);
     const auto rtp_sender_ports = boost::copy_range<std::vector<impl::port>>(impl::parse_ports(impl::fields::senders(settings)) | boost::adaptors::filtered(impl::is_rtp_port));
-    const auto rtp_sender_ids = impl::make_ids(seed_id, nmos::types::sender, rtp_sender_ports, how_many);
+    const auto rtp_sender_ids = impl::make_ids(seed_id, nmos::types::sender, rtp_sender_ports, senders_count_total);
     const auto ws_sender_ports = boost::copy_range<std::vector<impl::port>>(impl::parse_ports(impl::fields::senders(settings)) | boost::adaptors::filtered(impl::is_ws_port));
-    const auto ws_sender_ids = impl::make_ids(seed_id, nmos::types::sender, ws_sender_ports, how_many);
+    const auto ws_sender_ids = impl::make_ids(seed_id, nmos::types::sender, ws_sender_ports, senders_count_total);
     const auto ws_sender_uri = nmos::make_events_ws_api_connection_uri(device_id, settings);
     const auto rtp_receiver_ports = boost::copy_range<std::vector<impl::port>>(impl::parse_ports(impl::fields::receivers(settings)) | boost::adaptors::filtered(impl::is_rtp_port));
-    const auto rtp_receiver_ids = impl::make_ids(seed_id, nmos::types::receiver, rtp_receiver_ports, how_many);
+    const auto rtp_receiver_ids = impl::make_ids(seed_id, nmos::types::receiver, rtp_receiver_ports, receivers_count_total);
     const auto ws_receiver_ports = boost::copy_range<std::vector<impl::port>>(impl::parse_ports(impl::fields::receivers(settings)) | boost::adaptors::filtered(impl::is_ws_port));
-    const auto ws_receiver_ids = impl::make_ids(seed_id, nmos::types::receiver, ws_receiver_ports, how_many);
-
+    const auto ws_receiver_ids = impl::make_ids(seed_id, nmos::types::receiver, ws_receiver_ports, receivers_count_total);
     // although which properties may need to be defaulted depends on the resource type,
     // the default value will almost always be different for each resource
-    return [rtp_sender_ids, rtp_receiver_ids, ws_sender_ids, ws_sender_uri, ws_receiver_ids](const nmos::resource& resource, const nmos::resource& connection_resource, value& transport_params)
+    return [rtp_sender_ids, rtp_receiver_ids, ws_sender_ids, ws_sender_uri, ws_receiver_ids, &gate](const nmos::resource& resource, const nmos::resource& connection_resource, value& transport_params)
     {
         const std::pair<nmos::id, nmos::type> id_type{ connection_resource.id, connection_resource.type };
         // this code relies on the specific constraints added by node_implementation_thread
@@ -1528,21 +878,23 @@ nmos::connection_resource_auto_resolver make_node_implementation_auto_resolver(c
 }
 
 // Example Connection API activation callback to update senders' /transportfile endpoint - captures node_resources by reference!
-nmos::connection_sender_transportfile_setter make_node_implementation_transportfile_setter(const nmos::resources& node_resources, const nmos::settings& settings)
+nmos::connection_sender_transportfile_setter make_node_implementation_transportfile_setter(const nmos::resources& node_resources, const nmos::settings& settings, slog::base_gate& gate)
 {
     using web::json::value;
 
     const auto seed_id = nmos::experimental::fields::seed_id(settings);
     const auto node_id = impl::make_id(seed_id, nmos::types::node);
-    const auto how_many = impl::fields::how_many(settings);
+    //change
+    const auto senders_count = impl::parse_count(impl::fields::senders_count(settings)); // max count of elements = 4 (because 4 types of ports: video, audio, mux, data)
+    const auto senders_count_total = std::accumulate(senders_count.begin(), senders_count.end(), 0);
     const auto sender_ports = impl::parse_ports(impl::fields::senders(settings));
     const auto rtp_sender_ports = boost::copy_range<std::vector<impl::port>>(sender_ports | boost::adaptors::filtered(impl::is_rtp_port));
-    const auto rtp_source_ids = impl::make_ids(seed_id, nmos::types::source, rtp_sender_ports, how_many);
-    const auto rtp_flow_ids = impl::make_ids(seed_id, nmos::types::flow, rtp_sender_ports, how_many);
-    const auto rtp_sender_ids = impl::make_ids(seed_id, nmos::types::sender, rtp_sender_ports, how_many);
-
+    const auto rtp_source_ids = impl::make_ids(seed_id, nmos::types::source, rtp_sender_ports, senders_count_total);
+    const auto rtp_flow_ids = impl::make_ids(seed_id, nmos::types::flow, rtp_sender_ports, senders_count_total);
+    const auto rtp_sender_ids = impl::make_ids(seed_id, nmos::types::sender, rtp_sender_ports, senders_count_total);
+    const uint64_t payload_type_video = impl::fields::sender_payload_type(settings);
     // as part of activation, the example sender /transportfile should be updated based on the active transport parameters
-    return [&node_resources, node_id, rtp_source_ids, rtp_flow_ids, rtp_sender_ids](const nmos::resource& sender, const nmos::resource& connection_sender, value& endpoint_transportfile)
+    return [&node_resources, node_id, rtp_source_ids, rtp_flow_ids, rtp_sender_ids,payload_type_video,&gate](const nmos::resource& sender, const nmos::resource& connection_sender, value& endpoint_transportfile)
     {
         const auto found = boost::range::find(rtp_sender_ids, connection_sender.id);
         if (rtp_sender_ids.end() != found)
@@ -1576,13 +928,13 @@ nmos::connection_sender_transportfile_setter make_node_implementation_transportf
                     const nmos::media_type video_type{ nmos::fields::media_type(flow->data) };
                     if (nmos::media_types::video_raw == video_type)
                     {
-                        return nmos::make_video_sdp_parameters(node->data, source->data, flow->data, sender.data, nmos::details::payload_type_video_default, mids, {}, sdp::type_parameters::type_N);
+                        return nmos::make_video_sdp_parameters(node->data, source->data, flow->data, sender.data, payload_type_video, mids, {}, sdp::type_parameters::type_N);
                     }
                     else if (nmos::media_types::video_jxsv == video_type)
                     {
                         const auto params = nmos::make_video_jxsv_parameters(node->data, source->data, flow->data, sender.data);
                         const auto ts_refclk = nmos::details::make_ts_refclk(node->data, source->data, sender.data, {});
-                        return nmos::make_sdp_parameters(nmos::fields::label(sender.data), params, nmos::details::payload_type_video_default, mids, ts_refclk);
+                        return nmos::make_sdp_parameters(nmos::fields::label(sender.data), params, payload_type_video, mids, ts_refclk);
                     }
                     else
                     {
@@ -1621,10 +973,11 @@ nmos::connection_sender_transportfile_setter make_node_implementation_transportf
 nmos::events_ws_message_handler make_node_implementation_events_ws_message_handler(const nmos::node_model& model, slog::base_gate& gate)
 {
     const auto seed_id = nmos::experimental::fields::seed_id(model.settings);
-    const auto how_many = impl::fields::how_many(model.settings);
+    const auto receivers_count = impl::parse_count(impl::fields::receivers_count(model.settings)); // max count of elements = 4 (because 4 types of ports: video, audio, mux, data)
+    const auto receivers_count_total = std::accumulate(receivers_count.begin(), receivers_count.end(), 0);
     const auto receiver_ports = impl::parse_ports(impl::fields::receivers(model.settings));
     const auto ws_receiver_ports = boost::copy_range<std::vector<impl::port>>(receiver_ports | boost::adaptors::filtered(impl::is_ws_port));
-    const auto ws_receiver_ids = impl::make_ids(seed_id, nmos::types::receiver, ws_receiver_ports, how_many);
+    const auto ws_receiver_ids = impl::make_ids(seed_id, nmos::types::receiver, ws_receiver_ports, receivers_count_total);
 
     // the message handler will be used for all Events WebSocket connections, and each connection may potentially
     // have subscriptions to a number of sources, for multiple receivers, so this example uses a handler adaptor
@@ -1654,8 +1007,8 @@ nmos::events_ws_message_handler make_node_implementation_events_ws_message_handl
     }, gate);
 }
 
-// Example Connection API activation callback to perform application-specific operations to complete activation
-nmos::connection_activation_handler make_node_implementation_connection_activation_handler(nmos::node_model& model, slog::base_gate& gate)
+// Connection API activation callback to perform application-specific operations to complete activation
+nmos::connection_activation_handler make_node_implementation_connection_activation_handler(nmos::node_model& model, ConfigManager& config_manager, slog::base_gate& gate)
 {
     auto handle_load_ca_certificates = nmos::make_load_ca_certificates_handler(model.settings, gate);
     // this example uses this callback to (un)subscribe a IS-07 Events WebSocket receiver when it is activated
@@ -1666,14 +1019,198 @@ nmos::connection_activation_handler make_node_implementation_connection_activati
     auto connection_events_activation_handler = nmos::make_connection_events_websocket_activation_handler(handle_load_ca_certificates, handle_events_ws_message, handle_close, model.settings, gate);
     // this example uses this callback to update IS-12 Receiver-Monitor connection status
     auto receiver_monitor_connection_activation_handler = nmos::make_receiver_monitor_connection_activation_handler(model.control_protocol_resources);
-
-    return [connection_events_activation_handler, receiver_monitor_connection_activation_handler, &gate](const nmos::resource& resource, const nmos::resource& connection_resource)
+    return [connection_events_activation_handler, receiver_monitor_connection_activation_handler, &model, &config_manager, &gate](const nmos::resource& resource, const nmos::resource& connection_resource)
     {
         const std::pair<nmos::id, nmos::type> id_type{ resource.id, resource.type };
-        slog::log<slog::severities::info>(gate, SLOG_FLF) << nmos::stash_category(impl::categories::node_implementation) << "Activating " << id_type;
+        if(id_type.second == nmos::types::sender)
+        {
+            const char* vfio_port = "VFIO_PORT_TX";
+            const char* vfio_port_value_tx = std::getenv(vfio_port);
+            if (!vfio_port_value_tx) {
+                slog::log<slog::severities::error>(gate, SLOG_FLF) << "VFIO_PORT_TX environment variable is not set. You should export one of the virtual function interface port values.";
+                return;
+            }
+            std::thread ffmpegThread1;
+            slog::log<slog::severities::info>(gate, SLOG_FLF) << nmos::stash_category(impl::categories::node_implementation) << "this is "<< id_type << "---> sends json for sender";
+            auto data = connection_resource.data;
+            auto sender_source_ip = "192.168.2.4";//data[nmos::fields::endpoint_active][nmos::fields::transport_params][0][nmos::fields::source_ip];
+            auto receiver_destination_ip = "192.168.2.5";//data[nmos::fields::endpoint_active][nmos::fields::transport_params][0][nmos::fields::destination_ip];
+            auto receiver_destination_port = data[nmos::fields::endpoint_active][nmos::fields::transport_params][0][nmos::fields::destination_port];
+
+            // this data are necessary to send via grpc to ffmpeg
+            auto config_by_id = tracker::get_stream_info(id_type.first);
+            Video v;
+            v.frame_width=config_by_id.payload.video.frame_width;
+            v.frame_height=config_by_id.payload.video.frame_height;
+            v.frame_rate.numerator=config_by_id.payload.video.frame_rate.numerator;
+            v.frame_rate.denominator=config_by_id.payload.video.frame_rate.denominator;
+            v.pixel_format=config_by_id.payload.video.pixel_format;
+            v.video_type=config_by_id.payload.video.video_type;
+            Stream s;
+            if(config_by_id.stream_type.type==stream_type::mcm)
+            {
+                s.stream_type.type=stream_type::mcm;
+                s.stream_type.mcm.conn_type=config_by_id.stream_type.mcm.conn_type;
+                s.stream_type.mcm.transport=config_by_id.stream_type.mcm.transport;
+                s.stream_type.mcm.transport_pixel_format=config_by_id.stream_type.mcm.transport_pixel_format;
+                s.stream_type.mcm.ip=sender_source_ip; //.as_string();
+                s.stream_type.mcm.port=receiver_destination_port.as_integer();
+                s.stream_type.mcm.urn=config_by_id.stream_type.mcm.urn;
+            }
+            else if(config_by_id.stream_type.type==stream_type::st2110)
+            {
+                s.stream_type.type = stream_type::st2110;
+                s.stream_type.st2110.network_interface = vfio_port_value_tx;
+                s.stream_type.st2110.local_ip = sender_source_ip;//.as_string();
+                s.stream_type.st2110.remote_ip = receiver_destination_ip;//.as_string();
+                s.stream_type.st2110.transport = config_by_id.stream_type.st2110.transport;
+                s.stream_type.st2110.remote_port = receiver_destination_port.as_integer();
+                s.stream_type.st2110.payload_type = impl::fields::sender_payload_type(model.settings);
+            }
 
-        connection_events_activation_handler(resource, connection_resource);
+            Payload payload;
+            payload.type = payload_type::video;
+            payload.video = v;
+
+            s.payload = payload;
+
+            //sender=nmos, receiver=ffmpeg
+            // to get ffmpeg receivers of stream_type::File
+            auto configIntel = config_manager.get_config();
+            config_manager.print_config();
+
+            auto ffmpeg_receiver_as_file_vector = tracker::get_file_streams_receivers(configIntel);
+            for (auto& stream_receiver : ffmpeg_receiver_as_file_vector) {
+                stream_receiver.payload.type = payload_type::video;
+                std::cout<<"Ffmpeg RX file -> frame_width: "<<stream_receiver.payload.video.frame_width<<std::endl;
+            }
+
+            auto gpu_hw_acceleration_device = "";
+            if (configIntel.gpu_hw_acceleration == "intel") {
+                if (!configIntel.gpu_hw_acceleration_device.empty()) {
+                    slog::log<slog::severities::error>(gate, SLOG_FLF) << "GPU hardware acceleration device is not specified for Intel.";
+                }
+                gpu_hw_acceleration_device = configIntel.gpu_hw_acceleration_device.c_str();
+            }
+            int multiviewer_columns = 3;
+            if (configIntel.function == "multiviewer") {
+                multiviewer_columns = configIntel.multiviewer_columns;
+            }
+            // construct config for NMOS sender
+            const Config config = {{s}, ffmpeg_receiver_as_file_vector, configIntel.function, multiviewer_columns, configIntel.gpu_hw_acceleration, gpu_hw_acceleration_device, configIntel.logging_level};
+
+            ffmpegThread1=std::thread(grpc::sendDataToFfmpeg, impl::fields::ffmpeg_grpc_server_address(model.settings), impl::fields::ffmpeg_grpc_server_port(model.settings), config);
+
+            ffmpegThread1.join();
+}
+        if(id_type.second == nmos::types::receiver)
+        {
+            std::thread ffmpegThread2;
+            const char* vfio_port = "VFIO_PORT_RX";
+            const char* vfio_port_value_rx = std::getenv(vfio_port);
+            if (!vfio_port_value_rx) {
+                slog::log<slog::severities::error>(gate, SLOG_FLF) << "VFIO_PORT_RX environment variable is not set. You should export one of the virtual function interface port values.";
+                return;
+            }
+            auto data = connection_resource.data;
+            auto receiver_source_ip = "192.168.2.5";//data[nmos::fields::endpoint_active][nmos::fields::transport_params][0][nmos::fields::source_ip];
+            auto sender_destination_port = data[nmos::fields::endpoint_active][nmos::fields::transport_params][0][nmos::fields::destination_port];
+            auto sender_destination_ip = "192.168.2.4";//data[nmos::fields::endpoint_active][nmos::fields::transport_params][0][nmos::fields::destination_ip];
+            auto trasportfile_sdp = data[nmos::fields::endpoint_active][nmos::fields::transport_file][nmos::fields::data];
+            std::cout<<utility::us2s(trasportfile_sdp.as_string());
+            auto session_description = sdp::parse_session_description(utility::us2s(trasportfile_sdp.as_string()));
+            auto& media_descriptions = sdp::fields::media_descriptions(session_description);
+            auto& media_description = media_descriptions.at(0);
+            auto& media = sdp::fields::media(media_description);
+            auto& attributes = sdp::fields::attributes(media_description).as_array();
+            auto rtpmap = sdp::find_name(attributes, sdp::attributes::rtpmap);
+            auto& encoding_name = sdp::fields::encoding_name(sdp::fields::value(*rtpmap));
+            const auto& payload_type_sdp = sdp::fields::payload_type(sdp::fields::value(*rtpmap));
+            auto source_filter = sdp::find_name(attributes, sdp::attributes::source_filter);
+            auto& destination_addr=sdp::fields::destination_address(sdp::fields::value(*source_filter));
+
+            auto fmtp = sdp::find_name(attributes, sdp::attributes::fmtp);
+            auto& params = sdp::fields::format_specific_parameters(sdp::fields::value(*fmtp));
+            auto width_param = sdp::find_name(params, U("width"));
+            auto height_param = sdp::find_name(params, U("height"));
+            auto fps = sdp::find_name(params, U("exactframerate"));
+
+            // auto sampling = sdp::find_name(params, U("sampling"));
+            // auto depth = sdp::find_name(params, U("depth"));
+            // auto ssn = sdp::find_name(params, U("SSN"));
+
+            auto fps_numerator = nmos::details::parse_exactframerate(sdp::fields::value(*fps).as_string()).numerator();
+            auto fps_denominator = nmos::details::parse_exactframerate(sdp::fields::value(*fps).as_string()).denominator();
+
+            // this data are necessary to send via grpc to ffmpeg
+            auto config_by_id = tracker::get_stream_info(id_type.first);
+            config_manager.print_config();
+
+            Video v;
+            v.frame_width=std::stoi(sdp::fields::value(*width_param).as_string());
+            v.frame_height=std::stoi(sdp::fields::value(*height_param).as_string());
+            v.frame_rate.numerator=fps_numerator;
+            v.frame_rate.denominator=fps_denominator;
+            v.pixel_format=config_by_id.payload.video.pixel_format;
+            if (encoding_name == U("raw")) {
+                v.video_type = "rawvideo";
+            } else {
+                v.video_type = utility::us2s(encoding_name);
+            }
+            Stream s;
+            if(config_by_id.stream_type.type==stream_type::mcm)
+            {
+                s.stream_type.type=stream_type::mcm;
+                s.stream_type.mcm.conn_type=config_by_id.stream_type.mcm.conn_type;
+                s.stream_type.mcm.transport=config_by_id.stream_type.mcm.transport;
+                s.stream_type.mcm.transport_pixel_format=config_by_id.stream_type.mcm.transport_pixel_format;
+                s.stream_type.mcm.ip=receiver_source_ip;//.as_string();
+                s.stream_type.mcm.port=sender_destination_port.as_integer();
+                s.stream_type.mcm.urn=config_by_id.stream_type.mcm.urn;
+            }
+            else if(config_by_id.stream_type.type==stream_type::st2110)
+            {
+                s.stream_type.type = stream_type::st2110;
+                s.stream_type.st2110.network_interface = vfio_port_value_rx;
+                s.stream_type.st2110.local_ip = receiver_source_ip;//.as_string();
+                s.stream_type.st2110.remote_ip = sender_destination_ip;//destination_addr;
+                s.stream_type.st2110.transport = config_by_id.stream_type.st2110.transport;
+                s.stream_type.st2110.remote_port = sender_destination_port.as_integer();
+                s.stream_type.st2110.payload_type = payload_type_sdp;
+            }
+
+            Payload payload;
+            payload.type = payload_type::video;
+            payload.video = v;
+
+            s.payload = payload;
 
+            //receiver=nmos, sender=ffmpeg
+            //to get ffmpeg senders of stream_type::File
+            auto configIntel = config_manager.get_config();
+            auto ffmpeg_sender_as_file_vector = tracker::get_file_streams_senders(configIntel);
+            for (auto& stream_sender : ffmpeg_sender_as_file_vector) {
+                stream_sender.payload.type = payload_type::video;
+                std::cout<<"Ffmpeg TX file -> frame_width: "<<stream_sender.payload.video.frame_width<<std::endl;
+            }
+            auto gpu_hw_acceleration_device = "";
+            if (configIntel.gpu_hw_acceleration == "intel") {
+                if (!configIntel.gpu_hw_acceleration_device.empty()) {
+                    slog::log<slog::severities::error>(gate, SLOG_FLF) << "GPU hardware acceleration device is not specified for Intel.";
+                }
+                gpu_hw_acceleration_device = configIntel.gpu_hw_acceleration_device.c_str();
+            }
+            int multiviewer_columns = 3;
+            if (configIntel.function == "multiviewer") {
+                multiviewer_columns = configIntel.multiviewer_columns;
+            }
+            // construct config for NMOS sender
+            const Config config = {ffmpeg_sender_as_file_vector,{s},configIntel.function,multiviewer_columns, configIntel.gpu_hw_acceleration,gpu_hw_acceleration_device, configIntel.logging_level};
+
+            ffmpegThread2=std::thread(grpc::sendDataToFfmpeg, impl::fields::ffmpeg_grpc_server_address(model.settings), impl::fields::ffmpeg_grpc_server_port(model.settings), config);
+            ffmpegThread2.join();
+        }
+        connection_events_activation_handler(resource, connection_resource);
         receiver_monitor_connection_activation_handler(connection_resource);
     };
 }
@@ -1716,7 +1253,7 @@ nmos::control_protocol_property_changed_handler make_node_implementation_control
 
 namespace impl
 {
-    nmos::interlace_mode get_interlace_mode(const nmos::settings& settings)
+    nmos::interlace_mode get_interlace_mode(const nmos::rational& frame_rate, uint32_t frame_height, const nmos::settings& settings)
     {
         if (settings.has_field(impl::fields::interlace_mode))
         {
@@ -1726,8 +1263,8 @@ namespace impl
         // for 1080i formats, ST 2110-20 says that "the fields of an interlaced image are transmitted in time order,
         // first field first [and] the sample rows of the temporally second field are displaced vertically 'below' the
         // like-numbered sample rows of the temporally first field."
-        const auto frame_rate = nmos::parse_rational(impl::fields::frame_rate(settings));
-        const auto frame_height = impl::fields::frame_height(settings);
+        // const auto frame_rate = nmos::parse_rational(impl::fields::frame_rate(settings));
+        // const auto frame_height = impl::fields::frame_height(settings);
         return (nmos::rates::rate25 == frame_rate || nmos::rates::rate29_97 == frame_rate) && 1080 == frame_height
             ? nmos::interlace_modes::interlaced_tff
             : nmos::interlace_modes::progressive;
@@ -1752,6 +1289,15 @@ namespace impl
         }));
     }
 
+    std::vector<int> parse_count(const web::json::value& value)
+    {
+        if (value.is_null()) return {};
+        return boost::copy_range<std::vector<int>>(value.as_array() | boost::adaptors::transformed([&](const web::json::value& value)
+        {
+            return int{ value.as_integer() };
+        }));
+    }
+
     // find interface with the specified address
     std::vector<web::hosts::experimental::host_interface>::const_iterator find_interface(const std::vector<web::hosts::experimental::host_interface>& interfaces, const utility::string_t& address)
     {
@@ -1853,7 +1399,7 @@ namespace impl
 
 // This constructs all the callbacks used to integrate the example device-specific underlying implementation
 // into the server instance for the NMOS Node.
-nmos::experimental::node_implementation make_node_implementation(nmos::node_model& model, slog::base_gate& gate)
+nmos::experimental::node_implementation make_node_implementation(nmos::node_model& model, ConfigManager& config_manager, slog::base_gate& gate)
 {
     return nmos::experimental::node_implementation()
         .on_load_server_certificates(nmos::make_load_server_certificates_handler(model.settings, gate))
@@ -1861,12 +1407,11 @@ nmos::experimental::node_implementation make_node_implementation(nmos::node_mode
         .on_load_ca_certificates(nmos::make_load_ca_certificates_handler(model.settings, gate))
         .on_system_changed(make_node_implementation_system_global_handler(model, gate)) // may be omitted if not required
         .on_registration_changed(make_node_implementation_registration_handler(gate)) // may be omitted if not required
-        .on_parse_transport_file(make_node_implementation_transport_file_parser()) // may be omitted if the default is sufficient
-        .on_validate_connection_resource_patch(make_node_implementation_patch_validator()) // may be omitted if not required
-        .on_resolve_auto(make_node_implementation_auto_resolver(model.settings))
-        .on_set_transportfile(make_node_implementation_transportfile_setter(model.node_resources, model.settings))
-        .on_connection_activated(make_node_implementation_connection_activation_handler(model, gate))
+        .on_parse_transport_file(make_node_implementation_transport_file_parser(gate)) // may be omitted if the default is sufficient
+        .on_validate_connection_resource_patch(make_node_implementation_patch_validator(gate)) // may be omitted if not required
+        .on_resolve_auto(make_node_implementation_auto_resolver(model.settings, gate))
+        .on_set_transportfile(make_node_implementation_transportfile_setter(model.node_resources, model.settings, gate))
+        .on_connection_activated(make_node_implementation_connection_activation_handler(model, config_manager, gate))
         .on_validate_channelmapping_output_map(make_node_implementation_map_validator()) // may be omitted if not required
-        .on_channelmapping_activated(make_node_implementation_channelmapping_activation_handler(gate))
-        .on_control_protocol_property_changed(make_node_implementation_control_protocol_property_changed_handler(gate)); // may be omitted if IS-12 not required
+        .on_channelmapping_activated(make_node_implementation_channelmapping_activation_handler(gate));
 }
diff --git a/Development/nmos-cpp-node/node_implementation.h b/Development/nmos-cpp-node/node_implementation.h
index 3c6b295..2979150 100644
--- a/Development/nmos-cpp-node/node_implementation.h
+++ b/Development/nmos-cpp-node/node_implementation.h
@@ -1,6 +1,6 @@
 #ifndef NMOS_CPP_NODE_NODE_IMPLEMENTATION_H
 #define NMOS_CPP_NODE_NODE_IMPLEMENTATION_H
-
+#include "intel_config_parser.h"
 namespace slog
 {
     class base_gate;
@@ -20,10 +20,11 @@ namespace nmos
 // This is an example of how to integrate the nmos-cpp library with a device-specific underlying implementation.
 // It constructs and inserts a node resource and some sub-resources into the model, based on the model settings,
 // starts background tasks to emit regular events from the temperature event source, and then waits for shutdown.
-void node_implementation_thread(nmos::node_model& model, nmos::experimental::control_protocol_state& control_protocol_state, slog::base_gate& gate);
+
+void node_implementation_thread(nmos::node_model& model, nmos::experimental::control_protocol_state& control_protocol_state, ConfigManager& config_manager, slog::base_gate& gate);
 
 // This constructs all the callbacks used to integrate the example device-specific underlying implementation
 // into the server instance for the NMOS Node.
-nmos::experimental::node_implementation make_node_implementation(nmos::node_model& model, slog::base_gate& gate);
+nmos::experimental::node_implementation make_node_implementation(nmos::node_model& model, ConfigManager& config_manager, slog::base_gate& gate);
 
 #endif
diff --git a/Development/nmos/sdp_utils.cpp b/Development/nmos/sdp_utils.cpp
index 22f693b..c19b15b 100644
--- a/Development/nmos/sdp_utils.cpp
+++ b/Development/nmos/sdp_utils.cpp
@@ -1572,14 +1572,26 @@ namespace nmos
         {
             using web::json::value;

-            if (!nmos::caps::meta::enabled(constraint_set_)) return false;
+            if (!nmos::caps::meta::enabled(constraint_set_))
+            return false;
 
             const auto& constraint_set = constraint_set_.as_object();
-            return constraint_set.end() == std::find_if(constraint_set.begin(), constraint_set.end(), [&](const std::pair<utility::string_t, value>& constraint)
+            bool ret_val_3 =  constraint_set.end() == std::find_if(constraint_set.begin(), constraint_set.end(), [&](const std::pair<utility::string_t, value>& constraint)
             {
                 const auto found = constraints.find(constraint.first);
-                return constraints.end() != found && !found->second(sdp_params, format_params, constraint.second);
+                bool test_ret = constraints.end() != found;
+                bool return_val = constraints.end() != found && !found->second(sdp_params, format_params, constraint.second);
+                if (return_val==false)
+                {
+                    std::cout<<"TEST";
+                }
+                return return_val;
             });
+            if(ret_val_3==false)
+            {
+                std::cout<<"TEST";
+            }
+            return ret_val_3;
         }
 
         // Validate the specified SDP parameters and format-specific parameters against the specified receiver
@@ -1598,13 +1610,13 @@ namespace nmos
                 const auto found = std::find(media_types.begin(), media_types.end(), web::json::value::string(media_type.name));
                 if (media_types.end() == found) throw details::sdp_processing_error("unsupported encoding name");
             }
-            const auto& constraint_sets_or_null = nmos::fields::constraint_sets(caps);
-            if (!constraint_sets_or_null.is_null())
-            {
-                const auto& constraint_sets = constraint_sets_or_null.as_array();
-                const auto found = std::find_if(constraint_sets.begin(), constraint_sets.end(), [&](const web::json::value& constraint_set) { return details::match_sdp_parameters_constraint_set(constraints, sdp_params, format_params, constraint_set); });
-                if (constraint_sets.end() == found) throw details::sdp_processing_error("unsupported transport or format-specific parameters");
-            }
+            // const auto& constraint_sets_or_null = nmos::fields::constraint_sets(caps);
+            // if (!constraint_sets_or_null.is_null())
+            // {
+            //     const auto& constraint_sets = constraint_sets_or_null.as_array();
+            //     const auto found = std::find_if(constraint_sets.begin(), constraint_sets.end(), [&](const web::json::value& constraint_set) { return details::match_sdp_parameters_constraint_set(constraints, sdp_params, format_params, constraint_set); });
+            //     if (constraint_sets.end() == found) throw details::sdp_processing_error("unsupported transport or format-specific parameters");
+            // }
         }
     }
 
