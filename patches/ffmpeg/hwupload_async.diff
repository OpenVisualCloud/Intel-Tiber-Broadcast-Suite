diff --git a/libavfilter/avfilter.c b/libavfilter/avfilter.c
index ab7782862a..a4092bde61 100644
--- a/libavfilter/avfilter.c
+++ b/libavfilter/avfilter.c
@@ -1123,7 +1123,7 @@ static int ff_filter_frame_to_filter(AVFilterLink *link)
     ret = ff_filter_frame_framed(link, frame);
     if (ret < 0 && ret != link->status_out) {
         link_set_out_status(link, ret, AV_NOPTS_VALUE);
-    } else {
+    } else if (!dst->ready) {
         /* Run once again, to see if several frames were available, or if
            the input status has also changed, or any other reason. */
         ff_filter_set_ready(dst, 300);
@@ -1172,6 +1172,11 @@ static int ff_filter_activate_default(AVFilterContext *filter)
             return ff_filter_frame_to_filter(filter->inputs[i]);
         }
     }
+    for (i = 0; i < filter->nb_inputs; i++) {
+        if (filter->inputs[i]->dstpad->flags & AVFILTERPAD_FLAG_ASYNC) {
+            return filter->inputs[i]->dstpad->filter_frame(filter->inputs[i], NULL);
+        }
+    }
     for (i = 0; i < filter->nb_inputs; i++) {
         if (filter->inputs[i]->status_in && !filter->inputs[i]->status_out) {
             av_assert1(!ff_framequeue_queued_frames(&filter->inputs[i]->fifo));
diff --git a/libavfilter/internal.h b/libavfilter/internal.h
index 2dbc5def0a..30f6b6eac9 100644
--- a/libavfilter/internal.h
+++ b/libavfilter/internal.h
@@ -70,6 +70,11 @@ struct AVFilterPad {
      */
 #define AVFILTERPAD_FLAG_FREE_NAME                       (1 << 1)
 
+    /**
+     * The filter executes asynchronous operation.
+     */
+#define AVFILTERPAD_FLAG_ASYNC                           (1 << 2)
+
     /**
      * A combination of AVFILTERPAD_FLAG_* flags.
      */
diff --git a/libavfilter/vf_hwupload.c b/libavfilter/vf_hwupload.c
index ef61bb4137..912f2a2ef3 100644
--- a/libavfilter/vf_hwupload.c
+++ b/libavfilter/vf_hwupload.c
@@ -36,6 +36,9 @@ typedef struct HWUploadContext {
     AVBufferRef       *hwframes_ref;
     AVHWFramesContext *hwframes;
 
+    AVFrame *output;
+    AVFrame *input;
+
     char *device_type;
 } HWUploadContext;
 
@@ -176,6 +179,22 @@ static int hwupload_filter_frame(AVFilterLink *link, AVFrame *input)
     AVFrame *output = NULL;
     int err;
 
+    if (!input) {
+        if (!ctx->output || !ctx->input)
+            av_log(ctx, AV_LOG_ERROR, "Async operation already completed\n");
+
+        av_hwframe_transfer_data(ctx->output, NULL, 0);
+        av_frame_free(&ctx->input);
+        err = ff_filter_frame(outlink, ctx->output);
+        if (err < 0)
+            av_log(ctx, AV_LOG_ERROR, "Failed to complete async upload: %d.\n", err);
+
+        ctx->output = NULL;
+        ctx->input = NULL;
+        link->dstpad->flags &= ~AVFILTERPAD_FLAG_ASYNC;
+        return err;
+    }
+
     if (input->format == outlink->format)
         return ff_filter_frame(outlink, input);
 
@@ -190,6 +209,15 @@ static int hwupload_filter_frame(AVFilterLink *link, AVFrame *input)
     output->height = input->height;
 
     err = av_hwframe_transfer_data(output, input, 0);
+
+    if (err == AVERROR(EAGAIN)) {
+        link->dst->ready = 200;
+        link->dstpad->flags |= AVFILTERPAD_FLAG_ASYNC;
+        ctx->output = output;
+        ctx->input = input;
+        err = 0;
+    }
+
     if (err < 0) {
         av_log(ctx, AV_LOG_ERROR, "Failed to upload frame: %d.\n", err);
         goto fail;
@@ -199,6 +227,11 @@ static int hwupload_filter_frame(AVFilterLink *link, AVFrame *input)
     if (err < 0)
         goto fail;
 
+    if (link->dst->ready) {
+        // call again to complete frame filtering
+        return 0;
+    }
+
     av_frame_free(&input);
 
     return ff_filter_frame(outlink, output);
diff --git a/libavutil/hwcontext.c b/libavutil/hwcontext.c
index 5fd06016a6..c0fc0b549d 100644
--- a/libavutil/hwcontext.c
+++ b/libavutil/hwcontext.c
@@ -468,6 +468,16 @@ int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags)
     AVHWFramesContext *ctx;
     int ret;
 
+    if (!src) {
+        ctx = (AVHWFramesContext*)dst->hw_frames_ctx->data;
+        ret = ctx->internal->hw_type->transfer_data_to(ctx, dst, src);
+        if (ret < 0) {
+            av_log(ctx, AV_LOG_ERROR, "Delayed sync error.");
+            return AVERROR(ENOSYS);
+        }
+        return 0;
+    }
+
     if (!dst->buf[0])
         return transfer_data_alloc(dst, src, flags);
 
diff --git a/libavutil/hwcontext_qsv.c b/libavutil/hwcontext_qsv.c
index a29af0005b..d46d61c0c9 100644
--- a/libavutil/hwcontext_qsv.c
+++ b/libavutil/hwcontext_qsv.c
@@ -81,9 +81,15 @@ typedef struct QSVDeviceContext {
 
 typedef struct QSVFramesContext {
     mfxSession session_download;
+    mfxFrameSurface1 session_download_out;
+    mfxSyncPoint session_download_sync;
     atomic_int session_download_init;
+    int session_download_async_depth;
     mfxSession session_upload;
+    mfxFrameSurface1 session_upload_in;
+    mfxSyncPoint session_upload_sync;
     atomic_int session_upload_init;
+    int session_upload_async_depth;
 #if HAVE_PTHREADS
     pthread_mutex_t session_lock;
 #endif
@@ -1416,8 +1422,14 @@ static int qsv_frames_init(AVHWFramesContext *ctx)
     s->session_download = NULL;
     s->session_upload   = NULL;
 
+    memset(&s->session_download_out, 0, sizeof(s->session_download_out));
     s->session_download_init = 0;
+    s->session_download_sync = NULL;
+    s->session_download_async_depth = 0;
+    memset(&s->session_upload_in, 0, sizeof(s->session_upload_in));
     s->session_upload_init   = 0;
+    s->session_upload_sync   = NULL;
+    s->session_upload_async_depth  = 1;
 
 #if HAVE_PTHREADS
     pthread_mutex_init(&s->session_lock, NULL);
@@ -1766,10 +1778,8 @@ static int qsv_transfer_data_from(AVHWFramesContext *ctx, AVFrame *dst,
                                   const AVFrame *src)
 {
     QSVFramesContext  *s = ctx->internal->priv;
-    mfxFrameSurface1 out = {{ 0 }};
     mfxFrameSurface1 *in = (mfxFrameSurface1*)src->data[3];
 
-    mfxSyncPoint sync = NULL;
     mfxStatus err;
     int ret = 0;
     /* download to temp frame if the output is not padded as libmfx requires */
@@ -1781,6 +1791,19 @@ static int qsv_transfer_data_from(AVHWFramesContext *ctx, AVFrame *dst,
     if (ret < 0)
         return ret;
 
+    if ((s->session_download_async_depth == 1) && s->session_download_sync) {
+        do {
+            err = MFXVideoCORE_SyncOperation(s->session_download, s->session_download_sync, 1000);
+        } while (err == MFX_WRN_IN_EXECUTION);
+        if (err < 0) {
+            av_log(ctx, AV_LOG_ERROR, "Error synchronizing the operation: %d\n", err);
+            return AVERROR_UNKNOWN;
+        }
+        s->session_download_sync = NULL;
+        return 0;
+    }
+    s->session_download_sync = NULL;
+
     /* According to MSDK spec for mfxframeinfo, "Width must be a multiple of 16.
      * Height must be a multiple of 16 for progressive frame sequence and a
      * multiple of 32 otherwise.", so allign all frames to 16 before downloading. */
@@ -1810,28 +1833,20 @@ static int qsv_transfer_data_from(AVHWFramesContext *ctx, AVFrame *dst,
         return AVERROR(ENOSYS);
     }
 
-    out.Info = in->Info;
-    map_frame_to_surface(dst_frame, &out);
+    s->session_download_out.Info = in->Info;
+    map_frame_to_surface(dst_frame, &s->session_download_out);
 
     do {
-        err = MFXVideoVPP_RunFrameVPPAsync(s->session_download, in, &out, NULL, &sync);
+        err = MFXVideoVPP_RunFrameVPPAsync(s->session_download, in, &s->session_download_out, NULL, &s->session_download_sync);
         if (err == MFX_WRN_DEVICE_BUSY)
             av_usleep(1);
     } while (err == MFX_WRN_DEVICE_BUSY);
 
-    if (err < 0 || !sync) {
+    if (err < 0 || !s->session_download_sync) {
         av_log(ctx, AV_LOG_ERROR, "Error downloading the surface\n");
         return AVERROR_UNKNOWN;
     }
 
-    do {
-        err = MFXVideoCORE_SyncOperation(s->session_download, sync, 1000);
-    } while (err == MFX_WRN_IN_EXECUTION);
-    if (err < 0) {
-        av_log(ctx, AV_LOG_ERROR, "Error synchronizing the operation: %d\n", err);
-        return AVERROR_UNKNOWN;
-    }
-
     if (realigned) {
         tmp_frame->width  = dst->width;
         tmp_frame->height = dst->height;
@@ -1842,6 +1857,19 @@ static int qsv_transfer_data_from(AVHWFramesContext *ctx, AVFrame *dst,
             return ret;
     }
 
+    if (s->session_download_async_depth == 0) {
+        do {
+            err = MFXVideoCORE_SyncOperation(s->session_download, s->session_download_sync, 1000);
+        } while (err == MFX_WRN_IN_EXECUTION);
+
+        if (err < 0) {
+            av_log(ctx, AV_LOG_ERROR, "Error synchronizing the operation: %d\n", err);
+            return AVERROR_UNKNOWN;
+        }
+   } else {
+        return AVERROR(EAGAIN);
+    }
+
     return 0;
 }
 
@@ -1849,11 +1877,9 @@ static int qsv_transfer_data_to(AVHWFramesContext *ctx, AVFrame *dst,
                                 const AVFrame *src)
 {
     QSVFramesContext   *s = ctx->internal->priv;
-    mfxFrameSurface1   in = {{ 0 }};
     mfxFrameSurface1 *out = (mfxFrameSurface1*)dst->data[3];
     mfxFrameInfo tmp_info;
 
-    mfxSyncPoint sync = NULL;
     mfxStatus err;
     int ret = 0;
     /* make a copy if the input is not padded as libmfx requires */
@@ -1865,6 +1891,19 @@ static int qsv_transfer_data_to(AVHWFramesContext *ctx, AVFrame *dst,
     if (ret < 0)
         return ret;
 
+    if ((s->session_upload_async_depth == 1) && s->session_upload_sync) {
+        do {
+            err = MFXVideoCORE_SyncOperation(s->session_upload, s->session_upload_sync, 1000);
+        } while (err == MFX_WRN_IN_EXECUTION);
+        if (err < 0) {
+            av_log(ctx, AV_LOG_ERROR, "Error synchronizing the operation\n");
+            return AVERROR_UNKNOWN;
+        }
+        s->session_upload_sync = NULL;
+        return 0;
+    }
+    s->session_upload_sync = NULL;
+
     /* According to MSDK spec for mfxframeinfo, "Width must be a multiple of 16.
      * Height must be a multiple of 16 for progressive frame sequence and a
      * multiple of 32 otherwise.", so allign all frames to 16 before uploading. */
@@ -1908,33 +1947,37 @@ static int qsv_transfer_data_to(AVHWFramesContext *ctx, AVFrame *dst,
         return AVERROR(ENOSYS);
     }
 
-    in.Info = out->Info;
-    map_frame_to_surface(src_frame, &in);
+    s->session_upload_in.Info = out->Info;
+    map_frame_to_surface(src_frame, &s->session_upload_in);
 
     do {
-        err = MFXVideoVPP_RunFrameVPPAsync(s->session_upload, &in, out, NULL, &sync);
+        err = MFXVideoVPP_RunFrameVPPAsync(s->session_upload, &s->session_upload_in, out, NULL, &s->session_upload_sync);
         if (err == MFX_WRN_DEVICE_BUSY)
             av_usleep(1);
     } while (err == MFX_WRN_DEVICE_BUSY);
 
-    if (err < 0 || !sync) {
+    if (err < 0 || !s->session_upload_sync) {
         av_log(ctx, AV_LOG_ERROR, "Error uploading the surface\n");
         return AVERROR_UNKNOWN;
     }
 
-    do {
-        err = MFXVideoCORE_SyncOperation(s->session_upload, sync, 1000);
-    } while (err == MFX_WRN_IN_EXECUTION);
-    if (err < 0) {
-        av_log(ctx, AV_LOG_ERROR, "Error synchronizing the operation\n");
-        return AVERROR_UNKNOWN;
-    }
-
     if (realigned) {
         out->Info.CropW = tmp_info.CropW;
         out->Info.CropH = tmp_info.CropH;
     }
 
+    if (s->session_upload_async_depth == 0) {
+        do {
+            err = MFXVideoCORE_SyncOperation(s->session_upload, s->session_upload_sync, 1000);
+        } while (err == MFX_WRN_IN_EXECUTION);
+        if (err < 0) {
+            av_log(ctx, AV_LOG_ERROR, "Error synchronizing the operation\n");
+            return AVERROR_UNKNOWN;
+        }
+    } else {
+        return AVERROR(EAGAIN);
+    }
+
     return 0;
 }
 
 